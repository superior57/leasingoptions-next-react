{"code":"(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[13],{MHX4:function(e,t,r){\"use strict\";r.d(t,\"a\",(function(){return we})),r.d(t,\"b\",(function(){return Se})),r.d(t,\"c\",(function(){return pe})),r.d(t,\"d\",(function(){return Ee}));var n=r(\"q1tI\"),c=e=>null==e,s=e=>Array.isArray(e);const u=e=>\"object\"===typeof e;var a=e=>!c(e)&&!s(e)&&u(e),i=e=>a(e)&&e.nodeType===Node.ELEMENT_NODE;const o={onBlur:\"onBlur\",onChange:\"onChange\",onSubmit:\"onSubmit\"},l=\"value\",f=\"undefined\",d=\"blur\",b=\"change\",O=\"input\",g=\"max\",m=\"min\",h=\"maxLength\",j=\"minLength\",v=\"pattern\",p=\"required\",y=\"validate\",R=/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,E=/^\\w*$/,S=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,w=/\\\\(\\\\)?/g;var C=e=>!s(e)&&(E.test(e)||!R.test(e)),k=e=>{const t=[];return e.replace(S,((e,r,n,c)=>{t.push(n?c.replace(w,\"$1\"):r||e)})),t};function V(e,t,r){let n=-1;const c=C(t)?[t]:k(t),u=c.length,i=u-1;for(;++n<u;){const t=c[n];let u=r;if(n!==i){const r=e[t];u=a(r)||s(r)?r:isNaN(+c[n+1])?{}:[]}e[t]=u,e=e[t]}return e}var B=e=>Object.entries(e).reduce(((e,[t,r])=>C(t)?Object.assign(Object.assign({},e),{[t]:r}):(V(e,t,r),e)),{}),N=e=>void 0===e,F=(e,t,r)=>{const n=t.split(/[,[\\].]+?/).filter(Boolean).reduce(((e,t)=>c(e)?e:e[t]),e);return N(n)||n===e?N(e[t])?r:e[t]:n},x=(e,t)=>{i(e)&&e.removeEventListener&&(e.removeEventListener(O,t),e.removeEventListener(b,t),e.removeEventListener(d,t))},L=e=>\"radio\"===e.type,M=e=>\"checkbox\"===e.type;function $(e){return!e||e instanceof HTMLElement&&e.nodeType!==Node.DOCUMENT_NODE&&$(e.parentNode)}var A=e=>a(e)&&!Object.keys(e).length;function D(e){return s(e)?e:k(e)}function W(e,t){return 1==t.length?e:function(e,t){const r=C(t)?[t]:D(t),n=t.length;let c=0;for(;c<n;)e=N(e)?c++:e[r[c++]];return c==n?e:void 0}(e,function(e,t,r){let n=-1,c=e.length;t<0&&(t=-t>c?0:c+t),(r=r>c?c:r)<0&&(r+=c),c=t>r?0:r-t;const s=Array(c);for(;++n<c;)s[n]=e[n+t];return s}(t,0,-1))}function P(e,t){return t.forEach((t=>{!function(e,t){const r=C(t)?[t]:D(t),n=W(e,r),c=r[r.length-1],u=!(null!=n)||delete n[c];let i;for(let o=0;o<r.slice(0,-1).length;o++){let t,n=-1;const c=r.slice(0,-(o+1)),u=c.length-1;for(o>0&&(i=e);++n<c.length;){const r=c[n];t=t?t[r]:e[r],u===n&&(a(t)&&A(t)||s(t)&&!t.filter((e=>a(e)&&!A(e))).length)&&(i?delete i[r]:delete e[r]),i=t}}}(e,t)})),e}const T=(e,t)=>e&&e.ref===t;const _={isValid:!1,value:\"\"};var z=e=>s(e)?e.reduce(((e,t)=>t&&t.ref.checked?{isValid:!0,value:t.ref.value}:e),_):_,q=e=>\"file\"===e.type,H=e=>\"select-multiple\"===e.type,I=e=>\"\"===e;const J={value:!1,isValid:!1},U={value:!0,isValid:!0};var X=e=>{if(s(e)){if(e.length>1){const t=e.filter((e=>e&&e.ref.checked)).map((({ref:{value:e}})=>e));return{value:t,isValid:!!t.length}}const{checked:t,value:r,attributes:n}=e[0].ref;return t?n&&!N(n.value)?N(r)||I(r)?U:{value:r,isValid:!0}:U:J}return J};function G(e,t){const{name:r,value:n}=t,c=e[r];return q(t)?t.files:L(t)?c?z(c.options).value:\"\":H(t)?(s=t.options,[...s].filter((({selected:e})=>e)).map((({value:e})=>e))):M(t)?!!c&&X(c.options).value:n;var s}var K=e=>\"string\"===typeof e,Q=(e,t)=>{const r={};for(const n in e)(N(t)||(K(t)?n.startsWith(t):s(t)?t.find((e=>n.startsWith(e))):t&&t.nest))&&(r[n]=G(e,e[n].ref));return r},Y=(e,{type:t,types:r,message:n})=>a(e)&&e.type===t&&e.message===n&&((e={},t={})=>{const r=Object.keys(e),n=Object.keys(t);return r.length===n.length&&r.every((r=>t[r]&&t[r]===e[r]))})(e.types,r);var Z=e=>e instanceof RegExp,ee=e=>{return a(t=e)&&!Z(t)?e:{value:e,message:\"\"};var t},te=e=>\"function\"===typeof e,re=e=>\"boolean\"===typeof e,ne=e=>K(e)||a(e)&&Object(n.isValidElement)(e);function ce(e,t,r=\"validate\"){if(ne(e)||re(e)&&!e)return{type:r,message:ne(e)?e:\"\",ref:t}}var se=(e,t,r,n,c)=>{if(t){const t=r[e];return Object.assign(Object.assign({},t),{types:Object.assign(Object.assign({},t&&t.types?t.types:{}),{[n]:c||!0})})}return{}},ue=async(e,t,{ref:r,ref:{type:n,value:s,name:u},options:i,required:o,maxLength:l,minLength:f,min:d,max:b,pattern:O,validate:R})=>{var E;const S=e.current,w={},C=L(r),k=M(r),V=C||k,B=I(s),N=se.bind(null,u,t,w),F=(e,n,c,s=h,a=j)=>{const i=e?n:c;if(w[u]=Object.assign({type:e?s:a,message:i,ref:r},N(e?s:a,i)),!t)return w};if(o&&(!C&&!k&&(B||c(s))||re(s)&&!s||k&&!X(i).isValid||C&&!z(i).isValid)){const{value:e,message:n}=ne(o)?{value:!!o,message:o}:ee(o);if(e&&(w[u]=Object.assign({type:p,message:n,ref:V?null===(E=S[u].options)||void 0===E?void 0:E[0].ref:r},N(p,n)),!t))return w}if(!c(d)||!c(b)){let e,u;const{value:a,message:i}=ee(b),{value:o,message:l}=ee(d);if(\"number\"===n||!n&&!isNaN(s)){const t=r.valueAsNumber||parseFloat(s);c(a)||(e=t>a),c(o)||(u=t<o)}else{const t=r.valueAsDate||new Date(s);K(a)&&(e=t>new Date(a)),K(o)&&(u=t<new Date(o))}if((e||u)&&(F(!!e,i,l,g,m),!t))return w}if(K(s)&&!B&&(l||f)){const{value:e,message:r}=ee(l),{value:n,message:u}=ee(f),a=s.toString().length,i=!c(e)&&a>e,o=!c(n)&&a<n;if((i||o)&&(F(!!i,r,u),!t))return w}if(O&&!B){const{value:e,message:n}=ee(O);if(Z(e)&&!e.test(s)&&(w[u]=Object.assign({type:v,message:n,ref:r},N(v,n)),!t))return w}if(R){const e=G(S,r),n=V&&i?i[0].ref:r;if(te(R)){const r=ce(await R(e),n);if(r&&(w[u]=Object.assign(Object.assign({},r),N(y,r.message)),!t))return w}else if(a(R)){let r={};for(const[c,s]of Object.entries(R)){if(!A(r)&&!t)break;const a=ce(await s(e),n,c);a&&(r=Object.assign(Object.assign({},a),N(c,a.message)),t&&(w[u]=r))}if(!A(r)&&(w[u]=Object.assign({ref:n},r),!t))return w}}return w};const ae=(e,t)=>s(e.inner)?e.inner.reduce(((e,{path:r,message:n,type:c})=>Object.assign(Object.assign({},e),r?e[r]&&t?{[r]:se(r,t,e,c,n)}:{[r]:e[r]||Object.assign({message:n,type:c},t?{types:{[c]:n||!0}}:{})}:{})),{}):{[e.path]:{message:e.message,type:e.type}};async function ie(e,t,r,n,c){if(n)return n(r,c);try{return{values:await e.validate(r,{abortEarly:!1,context:c}),errors:{}}}catch(s){return{values:{},errors:B(ae(s,t))}}}var oe=e=>c(e)||!u(e);const le=(e,t)=>{const r=(t,r,n)=>{const c=n?`${e}.${r}`:`${e}[${r}]`;return oe(t)?c:le(c,t)};return s(t)?t.map(((e,t)=>r(e,t))):Object.entries(t).map((([e,t])=>r(t,e,!0)))};var fe=(e,t,r,n,c)=>{let s;return r.add(t),A(e)?s=void 0:N(e[t])?(s=F(B(e),t),N(s)||((e,t)=>le(e,t).flat(1/0))(t,s).forEach((e=>r.add(e)))):(s=e[t],r.add(t)),N(s)?c?n:F(n,t):s},de=({isOnChange:e,hasError:t,isBlurEvent:r,isOnSubmit:n,isReValidateOnSubmit:c,isOnBlur:s,isReValidateOnBlur:u,isSubmitted:a})=>e&&r||n&&c||n&&!a||s&&!r&&!t||u&&!r&&t||c&&a,be=e=>e.substring(0,e.indexOf(\"[\")),Oe=(e,t)=>{const r=B(Q(e));return t?F(r,t,r):r};function ge(e,t){let r=!1;if(!s(e)||!s(t)||e.length!==t.length)return!0;for(let n=0;n<e.length&&!r;n++){const c=e[n],s=t[n];if(N(s)||Object.keys(c).length!==Object.keys(s).length){r=!0;break}for(const e in c)if(c[e]!==s[e]){r=!0;break}}return r}const me=(e,t)=>RegExp(`^${t}[\\\\d+]`.replace(/\\[/g,\"\\\\[\").replace(/\\]/g,\"\\\\]\")).test(e);var he=(e,t)=>[...e].some((e=>me(t,e)));var je=e=>({isOnSubmit:!e||e===o.onSubmit,isOnBlur:e===o.onBlur,isOnChange:e===o.onChange}),ve=e=>L(e)||M(e);function pe({mode:e=o.onSubmit,reValidateMode:t=o.onChange,validationSchema:r,validationResolver:u,validationContext:l,defaultValues:g={},submitFocusError:m=!0,validateCriteriaMode:h}={}){const j=Object(n.useRef)({}),v=Object(n.useRef)({}),p=Object(n.useRef)({}),y=Object(n.useRef)({}),R=Object(n.useRef)(new Set),E=Object(n.useRef)(new Set),S=Object(n.useRef)(new Set),w=Object(n.useRef)(new Set),C=Object(n.useRef)(!0),k=Object(n.useRef)(g),D=Object(n.useRef)({}),W=Object(n.useRef)(!1),_=Object(n.useRef)(!1),z=Object(n.useRef)(!1),I=Object(n.useRef)(!1),J=Object(n.useRef)(0),U=Object(n.useRef)(!1),X=Object(n.useRef)(),Z=Object(n.useRef)({}),ee=Object(n.useRef)(l),ne=Object(n.useRef)(new Set),[,ce]=Object(n.useState)(),{isOnBlur:se,isOnSubmit:ae,isOnChange:le}=Object(n.useRef)(je(e)).current,me=\"all\"===h,pe=typeof window===f,ye=!(!r&&!u),Re=typeof document!==f&&!pe&&!N(window.HTMLElement),Ee=Re?\"Proxy\"in window:typeof Proxy!==f,Se=Object(n.useRef)({dirty:!Ee,dirtyFields:!Ee,isSubmitted:ae,submitCount:!Ee,touched:!Ee,isSubmitting:!Ee,isValid:!Ee}),{isOnBlur:we,isOnSubmit:Ce}=Object(n.useRef)(je(t)).current;ee.current=l;const ke=Object(n.useCallback)((()=>{W.current||ce({})}),[]),Ve=Object(n.useCallback)(((e,t,r=!1)=>{let n=r||function({errors:e,name:t,error:r,validFields:n,fieldsWithValidation:c}){const s=A(r),u=A(e),a=F(r,t),i=F(e,t);return!(s&&n.has(t)||i&&i.isManual)&&(!!(u!==s||!u&&!i||s&&c.has(t)&&!n.has(t))||a&&!Y(i,a))}({errors:v.current,error:t,name:e,validFields:w.current,fieldsWithValidation:S.current});if(A(t))(S.current.has(e)||ye)&&(w.current.add(e),n=n||F(v.current,e)),v.current=P(v.current,[e]);else{const r=F(v.current,e);w.current.delete(e),n=n||!r||!Y(r,t[e]),V(v.current,e,t[e])}if(n&&!c(r))return ke(),!0}),[ke,ye]),Be=Object(n.useCallback)(((e,t)=>{const{ref:r,options:n}=e,s=Re&&i(r)&&c(t)?\"\":t;L(r)&&n?n.forEach((({ref:e})=>e.checked=e.value===s)):q(r)?K(s)?r.value=s:r.files=s:H(r)?[...r.options].forEach((e=>e.selected=s.includes(e.value))):M(r)&&n?n.length>1?n.forEach((({ref:e})=>e.checked=s.includes(e.value))):n[0].ref.checked=!!s:r.value=s}),[Re]),Ne=Object(n.useCallback)((e=>{if(!j.current[e]||!Se.current.dirty&&!Se.current.dirtyFields)return!1;let t=D.current[e]!==G(j.current,j.current[e].ref);const r=he(ne.current,e),n=E.current.size;if(r){const r=be(e);t=ge(Oe(j.current,r),F(k.current,r))}const c=(r?I.current:E.current.has(e))!==t;return t?E.current.add(e):E.current.delete(e),I.current=r?t:!!E.current.size,Se.current.dirty?c:n!==E.current.size}),[]),Fe=Object(n.useCallback)(((e,t,r)=>{const n=s(t);for(const c in t){const s=`${r||e}${n?`[${c}]`:`.${c}`}`,u=j.current[s];a(t[c])&&Fe(e,t[c],s),u&&(Be(u,t[c]),Ne(s))}}),[Be,Ne]),xe=Object(n.useCallback)(((e,t)=>{const r=j.current[e];if(r){Be(r,t);const n=Ne(e);if(re(n))return n}else oe(t)||Fe(e,t)}),[Ne,Be,Fe]),Le=Object(n.useCallback)((async(e,t)=>{const r=j.current[e];if(r){const n=await ue(j,me,r);return Ve(e,n,!!t&&null),A(n)}return!1}),[Ve,me]),Me=Object(n.useCallback)((async e=>{const{errors:t}=await ie(r,me,Oe(j.current),u,ee.current),n=C.current;if(C.current=A(t),s(e))e.forEach((e=>{const r=F(t,e);r?V(v.current,e,r):P(v.current,[e])})),ke();else{const r=F(t,e);Ve(e,r?{[e]:r}:{},n!==C.current)}return A(v.current)}),[ke,Ve,me,u,r]),$e=Object(n.useCallback)((async e=>{const t=e||Object.keys(j.current);if(ye)return Me(t);if(s(t)){const e=await Promise.all(t.map((async e=>await Le(e,!0))));return ke(),e.every(Boolean)}return await Le(t)}),[Me,Le,ke,ye]),Ae=e=>_.current||R.current.has(e)||R.current.has((e.match(/\\w+/)||[])[0]);X.current=X.current?X.current:async({type:e,target:t})=>{const n=t?t.name:\"\",c=j.current,s=v.current,a=c[n],i=F(s,n);let o;if(!a)return;const l=e===d,f=de({hasError:!!i,isOnChange:le,isBlurEvent:l,isOnSubmit:ae,isReValidateOnSubmit:Ce,isOnBlur:se,isReValidateOnBlur:we,isSubmitted:z.current}),b=Ne(n);let O=Ae(n)||b;if(l&&!F(p.current,n)&&Se.current.touched&&(V(p.current,n,!0),O=!0),f)return O&&ke();if(ye){const{errors:e}=await ie(r,me,Oe(c),u,ee.current),t=C.current;C.current=A(e),o=F(e,n)?{[n]:F(e,n)}:{},t!==C.current&&(O=!0)}else o=await ue(j,me,a);!Ve(n,o)&&O&&ke()};const De=Object(n.useCallback)(((e={})=>{const t=A(k.current)?Q(j.current):k.current;ie(r,me,B(Object.assign(Object.assign({},t),e)),u,ee.current).then((({errors:e})=>{const t=C.current;C.current=A(e),t!==C.current&&ke()}))}),[ke,me,u]),We=Object(n.useCallback)(((e,t)=>{X.current&&e&&function(e,t,r,n){const{ref:c,ref:{name:u,type:a},mutationWatcher:i}=r,o=e[u];if(a)if((L(c)||M(c))&&o){const{options:r}=o;s(r)&&r.length?(r.filter(Boolean).forEach(((e,c)=>{const{ref:s,mutationWatcher:u}=e;(s&&$(s)&&T(e,s)||n)&&(x(s,t),u&&u.disconnect(),P(r,[`[${c}]`]))})),r&&!r.filter(Boolean).length&&delete e[u]):delete e[u]}else($(c)&&T(o,c)||n)&&(x(c,t),i&&i.disconnect(),delete e[u]);else delete e[u]}(j.current,X.current,e,t)}),[]),Pe=Object(n.useCallback)(((e,t)=>{if(!e||e&&he(ne.current,e.ref.name)&&!t)return;We(e,t);const{name:r}=e.ref;v.current=P(v.current,[r]),p.current=P(p.current,[r]),D.current=P(D.current,[r]),[E,S,w,R].forEach((e=>e.current.delete(r))),(Se.current.isValid||Se.current.touched)&&(ke(),ye&&De())}),[ke,ye,De,We]);const Te=({name:e,type:t,types:r,message:n,shouldRender:c})=>{const s=j.current[e];Y(F(v.current,e),{type:t,message:n,types:r})||(V(v.current,e,{type:t,types:r,message:n,ref:s?s.ref:{},isManual:!0}),c&&ke())};function _e(e,t={}){if(!e.name)return console.warn(\"Missing name @\",e);const{name:r,type:n,value:c}=e,u=Object.assign({ref:e},t),a=j.current,o=ve(e);let l,f,g=a[r],m=!0;if(o?g&&s(g.options)&&g.options.filter(Boolean).find((t=>c===t.ref.value&&t.ref===e)):g&&e===g.ref)a[r]=Object.assign(Object.assign({},g),t);else{if(n){const c=function(e,t){const r=new MutationObserver((()=>{$(e)&&(r.disconnect(),t())}));return r.observe(window.document,{childList:!0,subtree:!0}),r}(e,(()=>Pe(g)));g=o?Object.assign({options:[...g&&g.options||[],{ref:e,mutationWatcher:c}],ref:{type:n,name:r}},t):Object.assign(Object.assign({},u),{mutationWatcher:c})}else g=u;var h;a[r]=g,A(k.current)||(f=F(k.current,r),m=N(f),l=he(ne.current,r),m||l||Be(g,f)),ye&&!l&&Se.current.isValid?De():A(t)||(S.current.add(r),!ae&&Se.current.isValid&&ue(j,me,g).then((e=>{const t=C.current;A(e)?w.current.add(r):C.current=!1,t!==C.current&&ke()}))),D.current[r]||l&&m||(D.current[r]=m?G(a,g.ref):f),n&&function({field:{ref:e},handleChange:t,isRadioOrCheckbox:r}){i(e)&&t&&(e.addEventListener(r?b:O,t),e.addEventListener(d,t))}({field:o&&g.options?g.options[g.options.length-1]:g,isRadioOrCheckbox:o||(h=e,\"select-one\"===h.type),handleChange:X.current})}}const ze=Object(n.useCallback)((e=>async t=>{t&&(t.preventDefault(),t.persist());let n={};const c=j.current;let s=Q(c);Se.current.isSubmitting&&(U.current=!0,ke());try{if(ye){const{errors:e,values:t}=await ie(r,me,B(s),u,ee.current);v.current=e,n=e,s=t}else for(const e of Object.values(c))if(e){const{ref:{name:t}}=e,r=await ue(j,me,e);r[t]?(V(n,t,r[t]),w.current.delete(t)):S.current.has(t)&&w.current.add(t)}A(n)?(v.current={},ke(),await e(B(s),t)):(v.current=n,m&&Re&&((e,t)=>{for(const r in e)if(F(t,r)){const t=e[r];if(t){if(t.ref.focus){t.ref.focus();break}if(t.options){t.options[0].ref.focus();break}}}})(c,n))}finally{z.current=!0,U.current=!1,J.current=J.current+1,ke()}}),[Re,ke,ye,m,me,u,r]);Object(n.useEffect)((()=>()=>{W.current=!0,j.current&&Object.values(j.current).forEach((e=>Pe(e,!0)))}),[Pe]),ye||(C.current=w.current.size>=S.current.size&&A(v.current));const qe={dirty:I.current,dirtyFields:E.current,isSubmitted:z.current,submitCount:J.current,touched:p.current,isSubmitting:U.current,isValid:ae?z.current&&A(v.current):C.current},He={triggerValidation:$e,setValue:Object(n.useCallback)((function(e,t,r){let n=!1;const c=s(e);(c?e:[e]).forEach((e=>{const r=K(e);n=!(!xe(r?e:Object.keys(e)[0],r?t:Object.values(e)[0])&&!c)||Ae(e)})),(n||c)&&ke(),(r||c&&t)&&$e(c?void 0:e)}),[ke,xe,$e]),register:Object(n.useCallback)((function(e,t){if(!pe)if(K(e))_e({name:e},t);else{if(!a(e)||!(\"name\"in e))return t=>t&&_e(t,e);_e(e,t)}}),[k.current,D.current]),unregister:Object(n.useCallback)((function(e){j.current&&(s(e)?e:[e]).forEach((e=>Pe(j.current[e],!0)))}),[]),getValues:Object(n.useCallback)((function(e){if(K(e))return j.current[e]?G(j.current,j.current[e].ref):F(k.current,e);const t=Q(j.current),r=A(t)?k.current:t;return e&&e.nest?B(r):r}),[]),formState:Ee?new Proxy(qe,{get:(e,t)=>{if(t in e)return Se.current[t]=!0,e[t]}}):qe},Ie=Object.assign(Object.assign(Object.assign({removeFieldEventListener:We,reRender:ke},ye?{validateSchemaIsValid:De}:{}),{mode:{isOnBlur:se,isOnSubmit:ae,isOnChange:le},reValidateMode:{isReValidateOnBlur:we,isReValidateOnSubmit:Ce},errorsRef:v,touchedFieldsRef:p,fieldsRef:j,isWatchAllRef:_,watchFieldsRef:R,resetFieldArrayFunctionRef:Z,fieldArrayDefaultValues:y,validFieldsRef:w,dirtyFieldsRef:E,fieldsWithValidationRef:S,fieldArrayNamesRef:ne,isDirtyRef:I,readFormStateRef:Se,defaultValuesRef:k}),He);return Object.assign({watch:function(e,t){const r=R.current,n=N(t),c=n?k.current:t,u=Q(j.current,e);if(K(e))return fe(u,e,r,n?F(c,e):t,!0);if(s(e))return e.reduce(((e,t)=>Object.assign(Object.assign({},e),{[t]:fe(u,t,r,c)})),{});_.current=!0;const a=!A(u)&&u||c;return e&&e.nest?B(a):a},control:Ie,handleSubmit:ze,reset:Object(n.useCallback)(((e,t={})=>{if(Re)for(const n of Object.values(j.current))if(n){const{ref:e,options:t}=n,c=ve(e)&&s(t)?t[0].ref:e;if(i(c))try{c.closest(\"form\").reset();break}catch(r){}}e&&(k.current=e),Object.values(Z.current).forEach((e=>te(e)&&e())),(({errors:e,dirty:t,isSubmitted:r,touched:n,isValid:c,submitCount:s,dirtyFields:u})=>{j.current={},e||(v.current={}),n||(p.current={}),c||(w.current=new Set,S.current=new Set,C.current=!0),t||(I.current=!1),u||(E.current=new Set),r||(z.current=!1),s||(J.current=0),D.current={},y.current={},R.current=new Set,_.current=!1})(t),ke()}),[]),clearError:Object(n.useCallback)((function(e){e?P(v.current,s(e)?e:[e]):v.current={},ke()}),[]),setError:Object(n.useCallback)((function(e,t=\"\",r){K(e)?Te(Object.assign(Object.assign({name:e},a(t)?{types:t,type:\"\"}:{type:t,message:r}),{shouldRender:!0})):s(e)&&(e.forEach((e=>Te(Object.assign({},e)))),ke())}),[]),errors:v.current},He)}function ye(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&\"function\"===typeof Object.getOwnPropertySymbols){var c=0;for(n=Object.getOwnPropertySymbols(e);c<n.length;c++)t.indexOf(n[c])<0&&Object.prototype.propertyIsEnumerable.call(e,n[c])&&(r[n[c]]=e[n[c]])}return r}const Re=Object(n.createContext)(null);function Ee(){return Object(n.useContext)(Re)}function Se(e){var{children:t,formState:r,errors:c}=e,s=ye(e,[\"children\",\"formState\",\"errors\"]);return Object(n.createElement)(Re.Provider,{value:Object.assign(Object.assign({},s),{formState:r,errors:c})},t)}const we=e=>{var{name:t,rules:r,as:c,onBlur:s,onChange:u,onChangeName:i=o.onChange,onBlurName:f=o.onBlur,valueName:d,defaultValue:b,control:O,onFocus:g}=e,m=ye(e,[\"name\",\"rules\",\"as\",\"onBlur\",\"onChange\",\"onChangeName\",\"onBlurName\",\"valueName\",\"defaultValue\",\"control\",\"onFocus\"]);const h=Ee(),{defaultValuesRef:j,setValue:v,register:p,unregister:y,errorsRef:R,removeFieldEventListener:E,triggerValidation:S,mode:{isOnSubmit:w,isOnBlur:C,isOnChange:k},reValidateMode:{isReValidateOnBlur:B,isReValidateOnSubmit:x},formState:{isSubmitted:L},touchedFieldsRef:M,readFormStateRef:$,reRender:A,fieldsRef:D,fieldArrayNamesRef:W}=O||h.control,[P,T]=Object(n.useState)(N(b)?F(j.current,t):b),_=Object(n.useRef)(P),z=re(P),q=C||B,H=Object(n.useRef)(r),I=Object(n.useRef)(g),J=!he(W.current,t);H.current=r;const U=()=>!de({hasError:!!F(R.current,t),isOnBlur:C,isOnSubmit:w,isOnChange:k,isReValidateOnBlur:B,isReValidateOnSubmit:x,isSubmitted:L}),X=e=>{const t=((e,t)=>oe(e)||!a(e.target)||a(e.target)&&!e.type?e:t||N(e.target.value)?e.target.checked:e.target.value)(e,z);return T(t),_.current=t,t},G=Object(n.useCallback)((()=>{J||E(D.current[t],!0),p(Object.defineProperty({name:t,focus:I.current},l,{set(e){T(e),_.current=e},get:()=>_.current}),H.current)}),[J,D,H,t,I,p,E]);Object(n.useEffect)((()=>()=>{!he(W.current,t)&&y(t)}),[y,t,W]),Object(n.useEffect)((()=>{G()}),[G]),Object(n.useEffect)((()=>{D.current[t]||(G(),J&&T(N(b)?F(j.current,t):b))}));const K=Object.assign(Object.assign(Object.assign(Object.assign({name:t},m),u?{[i]:(Q=u,(...e)=>v(t,X(Q(e)),U()))}:{[i]:e=>{const r=X(e);v(t,r,U())}}),{[f]:(...e)=>{s&&s(e),$.current.touched&&!F(M.current,t)&&(V(M.current,t,!0),A()),q&&S(t)}}),{[d||(z?\"checked\":l)]:P});var Q;return Object(n.isValidElement)(c)?Object(n.cloneElement)(c,K):Object(n.createElement)(c,K)}}}]);","map":{"version":3,"sources":["static/chunks/c06b63825f06ba970e26699b0c6bcf11c668d23c.42a87ee472f6851cdbaa.js"],"names":["window","push","MHX4","module","__webpack_exports__","__webpack_require__","d","Controller","FormContext","useForm","useFormContext","react__WEBPACK_IMPORTED_MODULE_0__","isNullOrUndefined","value","isArray","Array","isObjectType","isObject","isHTMLElement","nodeType","Node","ELEMENT_NODE","VALIDATION_MODE","onBlur","onChange","onSubmit","VALUE","UNDEFINED","EVENTS","INPUT_VALIDATION_RULES","REGEX_IS_DEEP_PROP","REGEX_IS_PLAIN_PROP","REGEX_PROP_NAME","REGEX_ESCAPE_CHAR","isKey","test","stringToPath","string","result","replace","match","number","quote","set","object","path","index","tempPath","length","lastIndex","key","newValue","objValue","isNaN","transformToNestObject","data","Object","entries","reduce","previous","assign","[object Object]","isUndefined","val","undefined","get","obj","defaultValue","split","filter","Boolean","removeAllEventListeners","ref","validateWithStateUpdate","removeEventListener","isRadioInput","element","type","isCheckBoxInput","isDetached","HTMLElement","DOCUMENT_NODE","parentNode","isEmptyObject","keys","castPath","parent","updatePath","baseGet","array","start","end","baseSlice","unset","paths","forEach","childObject","previousObjRef","k","slice","objectRef","currentPaths","currentPathsLength","item","baseUnset","isSameRef","fieldValue","defaultReturn","isValid","getRadioValue","options","option","checked","isFileInput","isMultipleSelect","isEmptyString","defaultResult","validResult","getCheckboxValue","values","map","attributes","getFieldValue","fields","name","field","files","selected","isString","getFieldsValues","search","output","startsWith","find","nest","isSameError","error","types","message","objectA","objectB","objectAKeys","objectBKeys","every","compareObject","isRegex","RegExp","getValueAndMessage","validationData","isFunction","isBoolean","isMessage","getValidateError","appendErrors","validateAllFieldCriteria","errors","validateField","async","fieldsRef","required","maxLength","minLength","min","max","pattern","validate","_a","current","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","requiredValue","requiredMessage","exceedMin","maxValue","maxMessage","minValue","minMessage","valueNumber","valueAsNumber","parseFloat","valueDate","valueAsDate","Date","maxLengthValue","minLengthValue","inputLength","toString","patternValue","patternMessage","validateRef","validateError","validationResult","validateFunction","parseErrorSchema","inner","validateWithSchema","validationSchema","validationResolver","context","abortEarly","e","isPrimitive","getPath","getInnerPath","pathWithIndex","assignWatchFields","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","parentPath","flat","Infinity","getPath$1","skipValidation","isOnChange","hasError","isBlurEvent","isOnSubmit","isReValidateOnSubmit","isOnBlur","isReValidateOnBlur","isSubmitted","getFieldArrayParentName","substring","indexOf","getFieldValueByName","results","getIsFieldsDifferent","referenceArray","differenceArray","isMatch","i","dataA","dataB","isMatchFieldArrayName","searchName","isNameInFieldArray","names","some","modeChecker","mode","isRadioOrCheckboxFunction","reValidateMode","validationContext","defaultValues","submitFocusError","validateCriteriaMode","errorsRef","touchedFieldsRef","fieldArrayDefaultValues","watchFieldsRef","Set","dirtyFieldsRef","fieldsWithValidationRef","validFieldsRef","isValidRef","defaultValuesRef","defaultValuesAtRenderRef","isUnMount","isWatchAllRef","isSubmittedRef","isDirtyRef","submitCountRef","isSubmittingRef","handleChangeRef","resetFieldArrayFunctionRef","validationContextRef","fieldArrayNamesRef","render","isWindowUndefined","shouldValidateSchemaOrResolver","isWeb","document","isProxyEnabled","Proxy","readFormStateRef","dirty","dirtyFields","submitCount","touched","isSubmitting","reRender","shouldRenderBaseOnError","shouldRender","shouldReRender","validFields","fieldsWithValidation","isFieldValid","isFormValid","currentFieldError","existFieldError","has","isManual","shouldRenderBasedOnError","previousError","delete","setFieldValue","rawValue","radioRef","selectRef","includes","checkboxRef","setDirty","isFieldDirty","isFieldArray","previousDirtyFieldsLength","size","fieldArrayName","isDirtyChanged","setInternalValues","parentFieldName","isValueArray","setInternalValue","executeValidation","skipReRender","executeSchemaOrResolverValidation","payload","previousFormIsValid","triggerValidation","Promise","all","isFieldWatched","target","currentError","shouldSkipValidation","shouldUpdateDirty","validateSchemaOrResolver","then","removeFieldEventListener","forceDelete","handleChange","mutationWatcher","disconnect","findRemovedFieldAndRemoveListener","removeFieldEventListenerAndRef","setInternalError","registerFieldsRef","validateOptions","console","warn","fieldRefAndValidationOptions","isEmptyDefaultValue","onDetachCallback","observer","MutationObserver","observe","childList","subtree","onDomRemove","addEventListener","attachEventListeners","handleSubmit","callback","preventDefault","persist","fieldErrors","fieldError","focus","focusOnErrorField","formState","commonProps","setValue","valueOrShouldValidate","shouldValidate","isArrayValue","isStringFieldName","register","refOrValidationOptions","validationOptions","unregister","getValues","outputValues","prop","control","validateSchemaIsValid","watch","fieldNames","isDefaultValueUndefined","combinedDefaultValues","reset","omitResetState","inputRef","closest","resetFieldArray","resetRefs","clearError","setError","__rest","s","t","p","prototype","hasOwnProperty","call","getOwnPropertySymbols","propertyIsEnumerable","FormGlobalContext","children","restMethods","Provider","rules","as","InnerComponent","onChangeName","onBlurName","valueName","onFocus","rest","methods","setInputStateValue","valueRef","isCheckboxInput","shouldReValidateOnBlur","rulesRef","onFocusRef","isNotFieldArray","commonTask","event","getInputValue","registerField","defineProperty","props","arg","args"],"mappings":"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"},"name":"static/chunks/c06b63825f06ba970e26699b0c6bcf11c668d23c.42a87ee472f6851cdbaa.js","input":"(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[13],{\n\n/***/ \"MHX4\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Controller; });\n/* unused harmony export ErrorMessage */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return FormContext; });\n/* unused harmony export useFieldArray */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return useForm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return useFormContext; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar isNullOrUndefined = (value) => value == null;\n\nvar isArray = (value) => Array.isArray(value);\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nvar isHTMLElement = (value) => isObject(value) && value.nodeType === Node.ELEMENT_NODE;\n\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n};\r\nconst VALUE = 'value';\r\nconst UNDEFINED = 'undefined';\r\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst SELECT = 'select';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\r\nconst REGEX_IS_DEEP_PROP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\nconst REGEX_IS_PLAIN_PROP = /^\\w*$/;\r\nconst REGEX_PROP_NAME = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\nconst REGEX_ESCAPE_CHAR = /\\\\(\\\\)?/g;\r\nconst REGEX_ARRAY_FIELD_INDEX = /[\\d+]/g;\n\nfunction attachEventListeners({ field: { ref }, handleChange, isRadioOrCheckbox, }) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isKey = (value) => !isArray(value) &&\r\n    (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));\n\nvar stringToPath = (string) => {\r\n    const result = [];\r\n    string.replace(REGEX_PROP_NAME, (match, number, quote, string) => {\r\n        result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);\r\n    });\r\n    return result;\r\n};\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!isKey(key)) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = path\r\n        .split(/[,[\\].]+?/)\r\n        .filter(Boolean)\r\n        .reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nfunction castPath(value) {\r\n    return isArray(value) ? value : stringToPath(value);\r\n}\r\nfunction baseGet(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const length = path.length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return index == length ? object : undefined;\r\n}\r\nfunction baseSlice(array, start, end) {\r\n    let index = -1;\r\n    let length = array.length;\r\n    if (start < 0) {\r\n        start = -start > length ? 0 : length + start;\r\n    }\r\n    end = end > length ? length : end;\r\n    if (end < 0) {\r\n        end += length;\r\n    }\r\n    length = start > end ? 0 : end - start;\r\n    const result = Array(length);\r\n    while (++index < length) {\r\n        result[index] = array[index + start];\r\n    }\r\n    return result;\r\n}\r\nfunction parent(object, path) {\r\n    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n}\r\nfunction baseUnset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const childObject = parent(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    const result = !(childObject != null) || delete childObject[key];\r\n    let previousObjRef = undefined;\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef = undefined;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index) {\r\n                if ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (isArray(objectRef) &&\r\n                        !objectRef.filter((data) => isObject(data) && !isEmptyObject(data))\r\n                            .length)) {\r\n                    previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n                }\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction unset(object, paths) {\r\n    paths.forEach((path) => {\r\n        baseUnset(object, path);\r\n    });\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\r\n    const { ref, ref: { name, type }, mutationWatcher, } = field;\r\n    const fieldValue = fields[name];\r\n    if (!type) {\r\n        delete fields[name];\r\n        return;\r\n    }\r\n    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldValue) {\r\n        const { options } = fieldValue;\r\n        if (isArray(options) && options.length) {\r\n            options.filter(Boolean).forEach((option, index) => {\r\n                const { ref, mutationWatcher } = option;\r\n                if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\r\n                    removeAllEventListeners(ref, handleChange);\r\n                    if (mutationWatcher) {\r\n                        mutationWatcher.disconnect();\r\n                    }\r\n                    unset(options, [`[${index}]`]);\r\n                }\r\n            });\r\n            if (options && !options.filter(Boolean).length) {\r\n                delete fields[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fields[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldValue, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        if (mutationWatcher) {\r\n            mutationWatcher.disconnect();\r\n        }\r\n        delete fields[name];\r\n    }\r\n}\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nvar isEmptyString = (value) => value === '';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || isEmptyString(value)\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fields, ref) {\r\n    const { name, value } = ref;\r\n    const field = fields[name];\r\n    if (isFileInput(ref)) {\r\n        return ref.files;\r\n    }\r\n    if (isRadioInput(ref)) {\r\n        return field ? getRadioValue(field.options).value : '';\r\n    }\r\n    if (isMultipleSelect(ref)) {\r\n        return getMultipleSelectValue(ref.options);\r\n    }\r\n    if (isCheckBoxInput(ref)) {\r\n        return field ? getCheckboxValue(field.options).value : false;\r\n    }\r\n    return value;\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar getFieldsValues = (fields, search) => {\r\n    const output = {};\r\n    for (const name in fields) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : isArray(search)\r\n                    ? search.find((data) => name.startsWith(data))\r\n                    : search && search.nest)) {\r\n            output[name] = getFieldValue(fields, fields[name].ref);\r\n        }\r\n    }\r\n    return output;\r\n};\n\nvar compareObject = (objectA = {}, objectB = {}) => {\r\n    const objectAKeys = Object.keys(objectA);\r\n    const objectBKeys = Object.keys(objectB);\r\n    return (objectAKeys.length === objectBKeys.length &&\r\n        objectAKeys.every((key) => objectB[key] && objectB[key] === objectA[key]));\r\n};\n\nvar isSameError = (error, { type, types, message }) => isObject(error) &&\r\n    error.type === type &&\r\n    error.message === message &&\r\n    compareObject(error.types, types);\n\nfunction shouldRenderBasedOnError({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isFieldValid = isEmptyObject(error);\r\n    const isFormValid = isEmptyObject(errors);\r\n    const currentFieldError = get(error, name);\r\n    const existFieldError = get(errors, name);\r\n    if ((isFieldValid && validFields.has(name)) ||\r\n        (existFieldError && existFieldError.isManual)) {\r\n        return false;\r\n    }\r\n    if (isFormValid !== isFieldValid ||\r\n        (!isFormValid && !existFieldError) ||\r\n        (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))) {\r\n        return true;\r\n    }\r\n    return currentFieldError && !isSameError(existFieldError, currentFieldError);\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => {\r\n    const isValueMessage = (value) => isObject(value) && !isRegex(value);\r\n    return isValueMessage(validationData)\r\n        ? validationData\r\n        : {\r\n            value: validationData,\r\n            message: '',\r\n        };\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nvar isMessage = (value) => isString(value) || (isObject(value) && Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(value));\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (validateAllFieldCriteria) {\r\n        const error = errors[name];\r\n        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n    }\r\n    return {};\r\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value, name }, options, required, maxLength, minLength, min, max, pattern, validate, }) => {\r\n    var _a;\r\n    const fields = fieldsRef.current;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = isEmptyString(value);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n        if (!validateAllFieldCriteria) {\r\n            return error;\r\n        }\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value: requiredValue, message: requiredMessage } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (requiredValue) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message: requiredMessage, ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number' || (!type && !isNaN(value))) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue)) {\r\n                exceedMax = valueNumber > maxValue;\r\n            }\r\n            if (!isNullOrUndefined(minValue)) {\r\n                exceedMin = valueNumber < minValue;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxValue)) {\r\n                exceedMax = valueDate > new Date(maxValue);\r\n            }\r\n            if (isString(minValue)) {\r\n                exceedMin = valueDate < new Date(minValue);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\r\n        const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fields, ref);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner)\r\n    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), (path\r\n        ? previous[path] && validateAllFieldCriteria\r\n            ? {\r\n                [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message),\r\n            }\r\n            : {\r\n                [path]: previous[path] || Object.assign({ message,\r\n                    type }, (validateAllFieldCriteria\r\n                    ? {\r\n                        types: { [type]: message || true },\r\n                    }\r\n                    : {})),\r\n            }\r\n        : {}))), {})\r\n    : {\r\n        [error.path]: { message: error.message, type: error.type },\r\n    };\r\nasync function validateWithSchema(validationSchema, validateAllFieldCriteria, data, validationResolver, context) {\r\n    if (validationResolver) {\r\n        return validationResolver(data, context);\r\n    }\r\n    try {\r\n        return {\r\n            values: await validationSchema.validate(data, {\r\n                abortEarly: false,\r\n                context,\r\n            }),\r\n            errors: {},\r\n        };\r\n    }\r\n    catch (e) {\r\n        return {\r\n            values: {},\r\n            errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria)),\r\n        };\r\n    }\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\r\n    const getInnerPath = (value, key, isObject) => {\r\n        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\r\n        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\r\n    };\r\n    return isArray(values)\r\n        ? values.map((value, key) => getInnerPath(value, key))\r\n        : Object.entries(values).map(([key, value]) => getInnerPath(value, key, true));\r\n};\r\nvar getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value;\r\n    watchFields.add(fieldName);\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else if (!isUndefined(fieldValues[fieldName])) {\r\n        value = fieldValues[fieldName];\r\n        watchFields.add(fieldName);\r\n    }\r\n    else {\r\n        value = get(transformToNestObject(fieldValues), fieldName);\r\n        if (!isUndefined(value)) {\r\n            getPath$1(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnChange, hasError, isBlurEvent, isOnSubmit, isReValidateOnSubmit, isOnBlur, isReValidateOnBlur, isSubmitted, }) => (isOnChange && isBlurEvent) ||\r\n    (isOnSubmit && isReValidateOnSubmit) ||\r\n    (isOnSubmit && !isSubmitted) ||\r\n    (isOnBlur && !isBlurEvent && !hasError) ||\r\n    (isReValidateOnBlur && !isBlurEvent && hasError) ||\r\n    (isReValidateOnSubmit && isSubmitted);\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nvar getFieldValueByName = (fields, name) => {\r\n    const results = transformToNestObject(getFieldsValues(fields));\r\n    return name ? get(results, name, results) : results;\r\n};\n\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\r\n    let isMatch = false;\r\n    if (!isArray(referenceArray) ||\r\n        !isArray(differenceArray) ||\r\n        referenceArray.length !== differenceArray.length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < referenceArray.length; i++) {\r\n        if (isMatch) {\r\n            break;\r\n        }\r\n        const dataA = referenceArray[i];\r\n        const dataB = differenceArray[i];\r\n        if (isUndefined(dataB) ||\r\n            Object.keys(dataA).length !== Object.keys(dataB).length) {\r\n            isMatch = true;\r\n            break;\r\n        }\r\n        for (const key in dataA) {\r\n            if (dataA[key] !== dataB[key]) {\r\n                isMatch = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return isMatch;\r\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(element, onDetachCallback) {\r\n    const observer = new MutationObserver(() => {\r\n        if (isDetached(element)) {\r\n            observer.disconnect();\r\n            onDetachCallback();\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, validationResolver, validationContext, defaultValues = {}, submitFocusError = true, validateCriteriaMode, } = {}) {\r\n    const fieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const errorsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const touchedFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const fieldArrayDefaultValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const watchFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const dirtyFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const fieldsWithValidationRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const validFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const isValidRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(true);\r\n    const defaultValuesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(defaultValues);\r\n    const defaultValuesAtRenderRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const isUnMount = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const isWatchAllRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const isSubmittedRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const isDirtyRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const submitCountRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(0);\r\n    const isSubmittingRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const handleChangeRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\r\n    const resetFieldArrayFunctionRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const validationContextRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(validationContext);\r\n    const fieldArrayNamesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const [, render] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])();\r\n    const { isOnBlur, isOnSubmit, isOnChange } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(modeChecker(mode)).current;\r\n    const validateAllFieldCriteria = validateCriteriaMode === 'all';\r\n    const isWindowUndefined = typeof window === UNDEFINED;\r\n    const shouldValidateSchemaOrResolver = !!(validationSchema || validationResolver);\r\n    const isWeb = typeof document !== UNDEFINED &&\r\n        !isWindowUndefined &&\r\n        !isUndefined(window.HTMLElement);\r\n    const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\n    const readFormStateRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({\r\n        dirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        isSubmitted: isOnSubmit,\r\n        submitCount: !isProxyEnabled,\r\n        touched: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit, } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(modeChecker(reValidateMode)).current;\r\n    validationContextRef.current = validationContext;\r\n    const reRender = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(() => {\r\n        if (!isUnMount.current) {\r\n            render({});\r\n        }\r\n    }, []);\r\n    const shouldRenderBaseOnError = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, error, shouldRender = false) => {\r\n        let shouldReRender = shouldRender ||\r\n            shouldRenderBasedOnError({\r\n                errors: errorsRef.current,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        if (isEmptyObject(error)) {\r\n            if (fieldsWithValidationRef.current.has(name) ||\r\n                shouldValidateSchemaOrResolver) {\r\n                validFieldsRef.current.add(name);\r\n                shouldReRender = shouldReRender || get(errorsRef.current, name);\r\n            }\r\n            errorsRef.current = unset(errorsRef.current, [name]);\r\n        }\r\n        else {\r\n            const previousError = get(errorsRef.current, name);\r\n            validFieldsRef.current.delete(name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    (previousError\r\n                        ? !isSameError(previousError, error[name])\r\n                        : true);\r\n            set(errorsRef.current, name, error[name]);\r\n        }\r\n        if (shouldReRender && !isNullOrUndefined(shouldRender)) {\r\n            reRender();\r\n            return true;\r\n        }\r\n    }, [reRender, shouldValidateSchemaOrResolver]);\r\n    const setFieldValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((field, rawValue) => {\r\n        const { ref, options } = field;\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref)) {\r\n            if (isString(value)) {\r\n                ref.value = value;\r\n            }\r\n            else {\r\n                ref.files = value;\r\n            }\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = value.includes(checkboxRef.value)))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, [isWeb]);\r\n    const setDirty = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name) => {\r\n        if (!fieldsRef.current[name] ||\r\n            (!readFormStateRef.current.dirty && !readFormStateRef.current.dirtyFields)) {\r\n            return false;\r\n        }\r\n        let isFieldDirty = defaultValuesAtRenderRef.current[name] !==\r\n            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const previousDirtyFieldsLength = dirtyFieldsRef.current.size;\r\n        if (isFieldArray) {\r\n            const fieldArrayName = getFieldArrayParentName(name);\r\n            isFieldDirty = getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, fieldArrayName), get(defaultValuesRef.current, fieldArrayName));\r\n        }\r\n        const isDirtyChanged = (isFieldArray ? isDirtyRef.current : dirtyFieldsRef.current.has(name)) !==\r\n            isFieldDirty;\r\n        if (isFieldDirty) {\r\n            dirtyFieldsRef.current.add(name);\r\n        }\r\n        else {\r\n            dirtyFieldsRef.current.delete(name);\r\n        }\r\n        isDirtyRef.current = isFieldArray\r\n            ? isFieldDirty\r\n            : !!dirtyFieldsRef.current.size;\r\n        return readFormStateRef.current.dirty\r\n            ? isDirtyChanged\r\n            : previousDirtyFieldsLength !== dirtyFieldsRef.current.size;\r\n    }, []);\r\n    const setInternalValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, value, parentFieldName) => {\r\n        const isValueArray = isArray(value);\r\n        for (const key in value) {\r\n            const fieldName = `${parentFieldName || name}${isValueArray ? `[${key}]` : `.${key}`}`;\r\n            const field = fieldsRef.current[fieldName];\r\n            if (isObject(value[key])) {\r\n                setInternalValues(name, value[key], fieldName);\r\n            }\r\n            if (field) {\r\n                setFieldValue(field, value[key]);\r\n                setDirty(fieldName);\r\n            }\r\n        }\r\n    }, [setFieldValue, setDirty]);\r\n    const setInternalValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, value) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            setFieldValue(field, value);\r\n            const output = setDirty(name);\r\n            if (isBoolean(output)) {\r\n                return output;\r\n            }\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value);\r\n        }\r\n    }, [setDirty, setFieldValue, setInternalValues]);\r\n    const executeValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (name, skipReRender) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            const error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            shouldRenderBaseOnError(name, error, skipReRender ? null : false);\r\n            return isEmptyObject(error);\r\n        }\r\n        return false;\r\n    }, [shouldRenderBaseOnError, validateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (payload) => {\r\n        const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fieldsRef.current), validationResolver, validationContextRef.current);\r\n        const previousFormIsValid = isValidRef.current;\r\n        isValidRef.current = isEmptyObject(errors);\r\n        if (isArray(payload)) {\r\n            payload.forEach((name) => {\r\n                const error = get(errors, name);\r\n                if (error) {\r\n                    set(errorsRef.current, name, error);\r\n                }\r\n                else {\r\n                    unset(errorsRef.current, [name]);\r\n                }\r\n            });\r\n            reRender();\r\n        }\r\n        else {\r\n            const error = get(errors, payload);\r\n            shouldRenderBaseOnError(payload, (error ? { [payload]: error } : {}), previousFormIsValid !== isValidRef.current);\r\n        }\r\n        return isEmptyObject(errorsRef.current);\r\n    }, [\r\n        reRender,\r\n        shouldRenderBaseOnError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const triggerValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (payload) => {\r\n        const fields = payload || Object.keys(fieldsRef.current);\r\n        if (shouldValidateSchemaOrResolver) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, true)));\r\n            reRender();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [\r\n        executeSchemaOrResolverValidation,\r\n        executeValidation,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n    ]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    function setValue(names, valueOrShouldValidate, shouldValidate) {\r\n        let shouldRender = false;\r\n        const isArrayValue = isArray(names);\r\n        (isArrayValue\r\n            ? names\r\n            : [names]).forEach((name) => {\r\n            const isStringFieldName = isString(name);\r\n            shouldRender =\r\n                setInternalValue(isStringFieldName ? name : Object.keys(name)[0], isStringFieldName\r\n                    ? valueOrShouldValidate\r\n                    : Object.values(name)[0]) || isArrayValue\r\n                    ? true\r\n                    : isFieldWatched(name);\r\n        });\r\n        if (shouldRender || isArrayValue) {\r\n            reRender();\r\n        }\r\n        if (shouldValidate || (isArrayValue && valueOrShouldValidate)) {\r\n            triggerValidation(isArrayValue ? undefined : names);\r\n        }\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            const name = target ? target.name : '';\r\n            const fields = fieldsRef.current;\r\n            const errors = errorsRef.current;\r\n            const field = fields[name];\r\n            const currentError = get(errors, name);\r\n            let error;\r\n            if (!field) {\r\n                return;\r\n            }\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const shouldSkipValidation = skipValidation({\r\n                hasError: !!currentError,\r\n                isOnChange,\r\n                isBlurEvent,\r\n                isOnSubmit,\r\n                isReValidateOnSubmit,\r\n                isOnBlur,\r\n                isReValidateOnBlur,\r\n                isSubmitted: isSubmittedRef.current,\r\n            });\r\n            const shouldUpdateDirty = setDirty(name);\r\n            let shouldRender = isFieldWatched(name) || shouldUpdateDirty;\r\n            if (isBlurEvent &&\r\n                !get(touchedFieldsRef.current, name) &&\r\n                readFormStateRef.current.touched) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                shouldRender = true;\r\n            }\r\n            if (shouldSkipValidation) {\r\n                return shouldRender && reRender();\r\n            }\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fields), validationResolver, validationContextRef.current);\r\n                const previousFormIsValid = isValidRef.current;\r\n                isValidRef.current = isEmptyObject(errors);\r\n                error = (get(errors, name)\r\n                    ? { [name]: get(errors, name) }\r\n                    : {});\r\n                if (previousFormIsValid !== isValidRef.current) {\r\n                    shouldRender = true;\r\n                }\r\n            }\r\n            else {\r\n                error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            }\r\n            if (!shouldRenderBaseOnError(name, error) && shouldRender) {\r\n                reRender();\r\n            }\r\n        };\r\n    const validateSchemaOrResolver = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((values = {}) => {\r\n        const fieldValues = isEmptyObject(defaultValuesRef.current)\r\n            ? getFieldsValues(fieldsRef.current)\r\n            : defaultValuesRef.current;\r\n        validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), validationResolver, validationContextRef.current).then(({ errors }) => {\r\n            const previousFormIsValid = isValidRef.current;\r\n            isValidRef.current = isEmptyObject(errors);\r\n            if (previousFormIsValid !== isValidRef.current) {\r\n                reRender();\r\n            }\r\n        });\r\n    }, \r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [reRender, validateAllFieldCriteria, validationResolver]);\r\n    const removeFieldEventListener = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((field, forceDelete) => {\r\n        if (handleChangeRef.current && field) {\r\n            findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((field, forceDelete) => {\r\n        if (!field ||\r\n            (field &&\r\n                isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) &&\r\n                !forceDelete)) {\r\n            return;\r\n        }\r\n        removeFieldEventListener(field, forceDelete);\r\n        const { name } = field.ref;\r\n        errorsRef.current = unset(errorsRef.current, [name]);\r\n        touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);\r\n        defaultValuesAtRenderRef.current = unset(defaultValuesAtRenderRef.current, [name]);\r\n        [\r\n            dirtyFieldsRef,\r\n            fieldsWithValidationRef,\r\n            validFieldsRef,\r\n            watchFieldsRef,\r\n        ].forEach((data) => data.current.delete(name));\r\n        if (readFormStateRef.current.isValid ||\r\n            readFormStateRef.current.touched) {\r\n            reRender();\r\n            if (shouldValidateSchemaOrResolver) {\r\n                validateSchemaOrResolver();\r\n            }\r\n        }\r\n    }, [\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        validateSchemaOrResolver,\r\n        removeFieldEventListener,\r\n    ]);\r\n    function clearError(name) {\r\n        if (name) {\r\n            unset(errorsRef.current, isArray(name) ? name : [name]);\r\n        }\r\n        else {\r\n            errorsRef.current = {};\r\n        }\r\n        reRender();\r\n    }\r\n    const setInternalError = ({ name, type, types, message, shouldRender, }) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!isSameError(get(errorsRef.current, name), {\r\n            type,\r\n            message,\r\n            types,\r\n        })) {\r\n            set(errorsRef.current, name, {\r\n                type,\r\n                types,\r\n                message,\r\n                ref: field ? field.ref : {},\r\n                isManual: true,\r\n            });\r\n            if (shouldRender) {\r\n                reRender();\r\n            }\r\n        }\r\n    };\r\n    function setError(name, type = '', message) {\r\n        if (isString(name)) {\r\n            setInternalError(Object.assign(Object.assign({ name }, (isObject(type)\r\n                ? {\r\n                    types: type,\r\n                    type: '',\r\n                }\r\n                : {\r\n                    type,\r\n                    message,\r\n                })), { shouldRender: true }));\r\n        }\r\n        else if (isArray(name)) {\r\n            name.forEach((error) => setInternalError(Object.assign({}, error)));\r\n            reRender();\r\n        }\r\n    }\r\n    function watch(fieldNames, defaultValue) {\r\n        const watchFields = watchFieldsRef.current;\r\n        const isDefaultValueUndefined = isUndefined(defaultValue);\r\n        const combinedDefaultValues = isDefaultValueUndefined\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isDefaultValueUndefined\r\n                ? get(combinedDefaultValues, fieldNames)\r\n                : defaultValue, true);\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = true;\r\n        const result = (!isEmptyObject(fieldValues) && fieldValues) || combinedDefaultValues;\r\n        return fieldNames && fieldNames.nest\r\n            ? transformToNestObject(result)\r\n            : result;\r\n    }\r\n    function unregister(name) {\r\n        if (fieldsRef.current) {\r\n            (isArray(name) ? name : [name]).forEach((fieldName) => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\r\n        }\r\n    }\r\n    function registerFieldsRef(ref, validateOptions = {}) {\r\n        if (!ref.name) {\r\n            // eslint-disable-next-line no-console\r\n            return console.warn('Missing name @', ref);\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let isFieldArray;\r\n        let defaultValue;\r\n        if (isRadioOrCheckbox\r\n            ? field &&\r\n                isArray(field.options) &&\r\n                field.options.filter(Boolean).find((option) => {\r\n                    return value === option.ref.value && option.ref === ref;\r\n                })\r\n            : field && ref === field.ref) {\r\n            fields[name] = Object.assign(Object.assign({}, field), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                            mutationWatcher,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), { mutationWatcher });\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        if (!isEmptyObject(defaultValuesRef.current)) {\r\n            defaultValue = get(defaultValuesRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(field, defaultValue);\r\n            }\r\n        }\r\n        if (shouldValidateSchemaOrResolver &&\r\n            !isFieldArray &&\r\n            readFormStateRef.current.isValid) {\r\n            validateSchemaOrResolver();\r\n        }\r\n        else if (!isEmptyObject(validateOptions)) {\r\n            fieldsWithValidationRef.current.add(name);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, validateAllFieldCriteria, field).then((error) => {\r\n                    const previousFormIsValid = isValidRef.current;\r\n                    isEmptyObject(error)\r\n                        ? validFieldsRef.current.add(name)\r\n                        : (isValidRef.current = false);\r\n                    if (previousFormIsValid !== isValidRef.current) {\r\n                        reRender();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultValuesAtRenderRef.current[name] &&\r\n            !(isFieldArray && isEmptyDefaultValue)) {\r\n            defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, field.ref) : defaultValue;\r\n        }\r\n        if (type) {\r\n            attachEventListeners({\r\n                field: isRadioOrCheckbox && field.options\r\n                    ? field.options[field.options.length - 1]\r\n                    : field,\r\n                isRadioOrCheckbox: isRadioOrCheckbox || isSelectInput(ref),\r\n                handleChange: handleChangeRef.current,\r\n            });\r\n        }\r\n    }\r\n    function register(refOrValidationOptions, validationOptions) {\r\n        if (isWindowUndefined) {\r\n            return;\r\n        }\r\n        if (isString(refOrValidationOptions)) {\r\n            registerFieldsRef({ name: refOrValidationOptions }, validationOptions);\r\n            return;\r\n        }\r\n        if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\r\n            registerFieldsRef(refOrValidationOptions, validationOptions);\r\n            return;\r\n        }\r\n        return (ref) => ref && registerFieldsRef(ref, refOrValidationOptions);\r\n    }\r\n    const handleSubmit = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((callback) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        const fields = fieldsRef.current;\r\n        let fieldValues = getFieldsValues(fields);\r\n        if (readFormStateRef.current.isSubmitting) {\r\n            isSubmittingRef.current = true;\r\n            reRender();\r\n        }\r\n        try {\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors, values } = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(fieldValues), validationResolver, validationContextRef.current);\r\n                errorsRef.current = errors;\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fields)) {\r\n                    if (field) {\r\n                        const { ref: { name }, } = field;\r\n                        const fieldError = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            validFieldsRef.current.delete(name);\r\n                        }\r\n                        else {\r\n                            if (fieldsWithValidationRef.current.has(name)) {\r\n                                validFieldsRef.current.add(name);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors)) {\r\n                errorsRef.current = {};\r\n                reRender();\r\n                await callback(transformToNestObject(fieldValues), e);\r\n            }\r\n            else {\r\n                errorsRef.current = fieldErrors;\r\n                if (submitFocusError && isWeb) {\r\n                    focusOnErrorField(fields, fieldErrors);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            isSubmittedRef.current = true;\r\n            isSubmittingRef.current = false;\r\n            submitCountRef.current = submitCountRef.current + 1;\r\n            reRender();\r\n        }\r\n    }, [\r\n        isWeb,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        submitFocusError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const resetRefs = ({ errors, dirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        fieldsRef.current = {};\r\n        if (!errors) {\r\n            errorsRef.current = {};\r\n        }\r\n        if (!touched) {\r\n            touchedFieldsRef.current = {};\r\n        }\r\n        if (!isValid) {\r\n            validFieldsRef.current = new Set();\r\n            fieldsWithValidationRef.current = new Set();\r\n            isValidRef.current = true;\r\n        }\r\n        if (!dirty) {\r\n            isDirtyRef.current = false;\r\n        }\r\n        if (!dirtyFields) {\r\n            dirtyFieldsRef.current = new Set();\r\n        }\r\n        if (!isSubmitted) {\r\n            isSubmittedRef.current = false;\r\n        }\r\n        if (!submitCount) {\r\n            submitCountRef.current = 0;\r\n        }\r\n        defaultValuesAtRenderRef.current = {};\r\n        fieldArrayDefaultValues.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (values) {\r\n            defaultValuesRef.current = values;\r\n        }\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        resetRefs(omitResetState);\r\n        reRender();\r\n    };\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return fieldsRef.current[payload]\r\n                ? getFieldValue(fieldsRef.current, fieldsRef.current[payload].ref)\r\n                : get(defaultValuesRef.current, payload);\r\n        }\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const outputValues = isEmptyObject(fieldValues)\r\n            ? defaultValuesRef.current\r\n            : fieldValues;\r\n        return payload && payload.nest\r\n            ? transformToNestObject(outputValues)\r\n            : outputValues;\r\n    }\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => () => {\r\n        isUnMount.current = true;\r\n        fieldsRef.current &&\r\n            \"production\" === 'production' &&\r\n            Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, [removeFieldEventListenerAndRef]);\r\n    if (!shouldValidateSchemaOrResolver) {\r\n        isValidRef.current =\r\n            validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&\r\n                isEmptyObject(errorsRef.current);\r\n    }\r\n    const formState = {\r\n        dirty: isDirtyRef.current,\r\n        dirtyFields: dirtyFieldsRef.current,\r\n        isSubmitted: isSubmittedRef.current,\r\n        submitCount: submitCountRef.current,\r\n        touched: touchedFieldsRef.current,\r\n        isSubmitting: isSubmittingRef.current,\r\n        isValid: isOnSubmit\r\n            ? isSubmittedRef.current && isEmptyObject(errorsRef.current)\r\n            : isValidRef.current,\r\n    };\r\n    const commonProps = {\r\n        triggerValidation,\r\n        setValue: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(setValue, [\r\n            reRender,\r\n            setInternalValue,\r\n            triggerValidation,\r\n        ]),\r\n        register: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(register, [\r\n            defaultValuesRef.current,\r\n            defaultValuesAtRenderRef.current,\r\n        ]),\r\n        unregister: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(unregister, []),\r\n        getValues: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(getValues, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = Object.assign(Object.assign(Object.assign({ removeFieldEventListener,\r\n        reRender }, (shouldValidateSchemaOrResolver\r\n        ? { validateSchemaIsValid: validateSchemaOrResolver }\r\n        : {})), { mode: {\r\n            isOnBlur,\r\n            isOnSubmit,\r\n            isOnChange,\r\n        }, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnSubmit,\r\n        }, errorsRef,\r\n        touchedFieldsRef,\r\n        fieldsRef,\r\n        isWatchAllRef,\r\n        watchFieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        fieldArrayDefaultValues,\r\n        validFieldsRef,\r\n        dirtyFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        isDirtyRef,\r\n        readFormStateRef,\r\n        defaultValuesRef }), commonProps);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(reset, []), clearError: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(clearError, []), setError: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(setError, []), errors: errorsRef.current }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormGlobalContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createContext\"])(null);\r\nfunction useFormContext() {\r\n    return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormGlobalContext);\r\n}\r\nfunction FormContext(_a) {\r\n    var { children, formState, errors } = _a, restMethods = __rest(_a, [\"children\", \"formState\", \"errors\"]);\r\n    return (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(FormGlobalContext.Provider, { value: Object.assign(Object.assign({}, restMethods), { formState, errors }) }, children));\r\n}\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nconst appendId = (value, keyName) => (Object.assign({ [keyName]: generateId() }, (isObject(value) ? value : { value })));\r\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\n\nvar getSortRemovedItems = (indexes, removeIndexes, updatedIndexes = [], count = 0, notFoundIndexes = []) => {\r\n    for (const removeIndex of removeIndexes) {\r\n        if (indexes.indexOf(removeIndex) < 0) {\r\n            notFoundIndexes.push(removeIndex);\r\n        }\r\n    }\r\n    for (const index of indexes.sort()) {\r\n        if (removeIndexes.indexOf(index) > -1) {\r\n            updatedIndexes.push(-1);\r\n            count++;\r\n        }\r\n        else {\r\n            updatedIndexes.push(index -\r\n                count -\r\n                (notFoundIndexes.length\r\n                    ? notFoundIndexes\r\n                        .map((notFoundIndex) => notFoundIndex < index)\r\n                        .filter(Boolean).length\r\n                    : 0));\r\n        }\r\n    }\r\n    return updatedIndexes;\r\n};\n\nconst removeAt = (data, index) => [\r\n    ...data.slice(0, index),\r\n    ...data.slice(index + 1),\r\n];\r\nfunction removeAtIndexes(data, index) {\r\n    let k = -1;\r\n    while (++k < data.length) {\r\n        if (index.indexOf(k) >= 0) {\r\n            delete data[k];\r\n        }\r\n    }\r\n    return data.filter(Boolean);\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : isArray(index)\r\n        ? removeAtIndexes(data, index)\r\n        : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(isArray(value) ? value : [value || null]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(isArray(value) ? value : [value || null]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => isArray(value) ? Array(value.length).fill(null) : null;\n\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    const { isWatchAllRef, resetFieldArrayFunctionRef, fieldArrayNamesRef, reRender, fieldsRef, getValues, defaultValuesRef, removeFieldEventListener, errorsRef, dirtyFieldsRef, isDirtyRef, touchedFieldsRef, readFormStateRef, watchFieldsRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValues, validateSchemaIsValid, } = control || methods.control;\r\n    const getDefaultValues = () => [\r\n        ...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)]\r\n            ? fieldArrayDefaultValues.current\r\n            : defaultValuesRef.current, name, []),\r\n    ];\r\n    const memoizedDefaultValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(getDefaultValues());\r\n    const [fields, setField] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(mapIds(memoizedDefaultValues.current, keyName));\r\n    const [isDeleted, setIsDeleted] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(false);\r\n    const allFields = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(fields);\r\n    const isNameKey = isKey(name);\r\n    allFields.current = fields;\r\n    if (isNameKey) {\r\n        fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\r\n    }\r\n    const appendValueWithKey = (values) => values.map((value) => appendId(value, keyName));\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setField(fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateSchemaIsValid) {\r\n            validateSchemaIsValid({\r\n                [name]: fieldsValues,\r\n            });\r\n        }\r\n    };\r\n    const modifyDirtyFields = ({ shouldRender, isRemove, isPrePend, index, value = {}, } = {}) => {\r\n        let render = shouldRender;\r\n        const values = isArray(value) ? value : [value];\r\n        if (readFormStateRef.current.dirty) {\r\n            const dirtyFieldIndexesAndValues = {};\r\n            if (isPrePend || isRemove) {\r\n                for (const dirtyField of [...dirtyFieldsRef.current].sort()) {\r\n                    if (isMatchFieldArrayName(dirtyField, name)) {\r\n                        const matchedIndexes = dirtyField.match(REGEX_ARRAY_FIELD_INDEX);\r\n                        if (matchedIndexes) {\r\n                            const matchIndex = +matchedIndexes[matchedIndexes.length - 1];\r\n                            if (dirtyFieldIndexesAndValues[matchIndex]) {\r\n                                dirtyFieldIndexesAndValues[matchIndex].push(dirtyField);\r\n                            }\r\n                            else {\r\n                                dirtyFieldIndexesAndValues[matchIndex] = [dirtyField];\r\n                            }\r\n                        }\r\n                        dirtyFieldsRef.current.delete(dirtyField);\r\n                    }\r\n                }\r\n            }\r\n            if (!isUndefined(index) || isPrePend) {\r\n                const updatedDirtyFieldIndexes = isUndefined(index)\r\n                    ? []\r\n                    : getSortRemovedItems(Object.keys(dirtyFieldIndexesAndValues).map((i) => +i), isArray(index) ? index : [index]);\r\n                Object.values(dirtyFieldIndexesAndValues).forEach((values, index) => {\r\n                    const updateIndex = isPrePend ? 0 : updatedDirtyFieldIndexes[index];\r\n                    if (updateIndex > -1) {\r\n                        for (const value of values) {\r\n                            const matchedIndexes = value.match(REGEX_ARRAY_FIELD_INDEX);\r\n                            if (matchedIndexes) {\r\n                                dirtyFieldsRef.current.add(value.replace(/[\\d+]([^[\\d+]+)$/, `${isPrePend\r\n                                    ? +matchedIndexes[matchedIndexes.length - 1] +\r\n                                        values.length\r\n                                    : updateIndex}$1`));\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            if (!isRemove) {\r\n                values.forEach((fieldValue, index) => Object.keys(fieldValue).forEach((key) => dirtyFieldsRef.current.add(`${name}[${isPrePend ? index : allFields.current.length + index}].${key}`)));\r\n                isDirtyRef.current = true;\r\n            }\r\n            render = true;\r\n        }\r\n        if (render && !isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n    };\r\n    const resetFields = (flagOrFields) => {\r\n        if (readFormStateRef.current.dirty) {\r\n            isDirtyRef.current = isUndefined(flagOrFields)\r\n                ? true\r\n                : getIsFieldsDifferent(flagOrFields, defaultValuesRef.current[name] || []);\r\n        }\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n            }\r\n        }\r\n    };\r\n    const mapCurrentFieldsValueWithState = () => {\r\n        const currentFieldsValue = get(getValues({ nest: true }), name);\r\n        if (isArray(currentFieldsValue)) {\r\n            for (let i = 0; i < currentFieldsValue.length; i++) {\r\n                allFields.current[i] = Object.assign(Object.assign({}, allFields.current[i]), currentFieldsValue[i]);\r\n            }\r\n        }\r\n    };\r\n    const append = (value) => {\r\n        setFieldAndValidState([\r\n            ...allFields.current,\r\n            ...(isArray(value)\r\n                ? appendValueWithKey(value)\r\n                : [appendId(value, keyName)]),\r\n        ]);\r\n        modifyDirtyFields({ value });\r\n    };\r\n    const prepend$1 = (value) => {\r\n        let shouldRender = false;\r\n        resetFields();\r\n        setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = prepend(errorsRef.current[name], fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], fillEmptyArray(value));\r\n            shouldRender = true;\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isPrePend: true,\r\n            value,\r\n        });\r\n    };\r\n    const remove = (index) => {\r\n        let shouldRender = false;\r\n        const isIndexUndefined = isUndefined(index);\r\n        if (!isIndexUndefined) {\r\n            mapCurrentFieldsValueWithState();\r\n        }\r\n        resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(removeArrayAt(allFields.current, index));\r\n        setIsDeleted(true);\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = removeArrayAt(errorsRef.current[name], index);\r\n            if (!errorsRef.current[name].filter(Boolean).length) {\r\n                delete errorsRef.current[name];\r\n            }\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);\r\n            shouldRender = true;\r\n        }\r\n        if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\r\n            let fieldIndex = -1;\r\n            let isFound = false;\r\n            const isIndexUndefined = isUndefined(index);\r\n            while (fieldIndex++ < fields.length) {\r\n                const isLast = fieldIndex === fields.length - 1;\r\n                const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\r\n                if (isCurrentIndex || isIndexUndefined) {\r\n                    isFound = true;\r\n                }\r\n                if (!isFound) {\r\n                    continue;\r\n                }\r\n                for (const key in fields[fieldIndex]) {\r\n                    const currentFieldName = `${name}[${fieldIndex}].${key}`;\r\n                    if (isCurrentIndex || isLast || isIndexUndefined) {\r\n                        validFieldsRef.current.delete(currentFieldName);\r\n                        fieldsWithValidationRef.current.delete(currentFieldName);\r\n                    }\r\n                    else {\r\n                        const previousFieldName = `${name}[${fieldIndex - 1}].${key}`;\r\n                        if (validFieldsRef.current.has(currentFieldName)) {\r\n                            validFieldsRef.current.add(previousFieldName);\r\n                        }\r\n                        if (fieldsWithValidationRef.current.has(currentFieldName)) {\r\n                            fieldsWithValidationRef.current.add(previousFieldName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isRemove: true,\r\n            index,\r\n        });\r\n    };\r\n    const insert$1 = (index, value) => {\r\n        mapCurrentFieldsValueWithState();\r\n        resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = insert(errorsRef.current[name], index, fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, fillEmptyArray(value));\r\n            reRender();\r\n        }\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields(fieldValues);\r\n        swapArrayAt(allFields.current, indexA, indexB);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            swapArrayAt(errorsRef.current[name], indexA, indexB);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\r\n            reRender();\r\n        }\r\n    };\r\n    const move = (from, to) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields(fieldValues);\r\n        moveArrayAt(allFields.current, from, to);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            moveArrayAt(errorsRef.current[name], from, to);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            moveArrayAt(touchedFieldsRef.current[name], from, to);\r\n            reRender();\r\n        }\r\n    };\r\n    const reset = () => {\r\n        resetFields();\r\n        memoizedDefaultValues.current = getDefaultValues();\r\n        setField(mapIds(memoizedDefaultValues.current, keyName));\r\n    };\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        if (isNameKey &&\r\n            isDeleted &&\r\n            fieldArrayDefaultValues.current[name] &&\r\n            fields.length < fieldArrayDefaultValues.current[name].length) {\r\n            fieldArrayDefaultValues.current[name].pop();\r\n        }\r\n    }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        if (isWatchAllRef && isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n        else if (watchFieldsRef) {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    reRender();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }, [fields, name, reRender, watchFieldsRef, isWatchAllRef]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        fieldArrayNames.add(name);\r\n        resetFunctions[name] = reset;\r\n        return () => {\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            fieldArrayNames.delete(name);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    return {\r\n        swap: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(swap, [name]),\r\n        move: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(move, [name]),\r\n        prepend: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(prepend$1, [name]),\r\n        append: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(append, [name]),\r\n        remove: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(remove, [fields, name]),\r\n        insert: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nvar getInputValue = (event, isCheckboxInput) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isCheckboxInput || isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nconst Controller = (_a) => {\r\n    var { name, rules, as: InnerComponent, onBlur, onChange, onChangeName = VALIDATION_MODE.onChange, onBlurName = VALIDATION_MODE.onBlur, valueName, defaultValue, control, onFocus } = _a, rest = __rest(_a, [\"name\", \"rules\", \"as\", \"onBlur\", \"onChange\", \"onChangeName\", \"onBlurName\", \"valueName\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, setValue, register, unregister, errorsRef, removeFieldEventListener, triggerValidation, mode: { isOnSubmit, isOnBlur, isOnChange }, reValidateMode: { isReValidateOnBlur, isReValidateOnSubmit }, formState: { isSubmitted }, touchedFieldsRef, readFormStateRef, reRender, fieldsRef, fieldArrayNamesRef, } = control || methods.control;\r\n    const [value, setInputStateValue] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(isUndefined(defaultValue)\r\n        ? get(defaultValuesRef.current, name)\r\n        : defaultValue);\r\n    const valueRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(value);\r\n    const isCheckboxInput = isBoolean(value);\r\n    const shouldReValidateOnBlur = isOnBlur || isReValidateOnBlur;\r\n    const rulesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(rules);\r\n    const onFocusRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(onFocus);\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    rulesRef.current = rules;\r\n    const shouldValidate = () => !skipValidation({\r\n        hasError: !!get(errorsRef.current, name),\r\n        isOnBlur,\r\n        isOnSubmit,\r\n        isOnChange,\r\n        isReValidateOnBlur,\r\n        isReValidateOnSubmit,\r\n        isSubmitted,\r\n    });\r\n    const commonTask = (event) => {\r\n        const data = getInputValue(event, isCheckboxInput);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    };\r\n    const eventWrapper = (event) => (...arg) => setValue(name, commonTask(event(arg)), shouldValidate());\r\n    const handleChange = (event) => {\r\n        const data = commonTask(event);\r\n        setValue(name, data, shouldValidate());\r\n    };\r\n    const registerField = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(() => {\r\n        if (!isNotFieldArray) {\r\n            removeFieldEventListener(fieldsRef.current[name], true);\r\n        }\r\n        register(Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\r\n            set(data) {\r\n                setInputStateValue(data);\r\n                valueRef.current = data;\r\n            },\r\n            get() {\r\n                return valueRef.current;\r\n            },\r\n        }), rulesRef.current);\r\n    }, [\r\n        isNotFieldArray,\r\n        fieldsRef,\r\n        rulesRef,\r\n        name,\r\n        onFocusRef,\r\n        register,\r\n        removeFieldEventListener,\r\n    ]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => () => {\r\n        !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\r\n    }, [unregister, name, fieldArrayNamesRef]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        registerField();\r\n    }, [registerField]);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        if (!fieldsRef.current[name]) {\r\n            registerField();\r\n            if (isNotFieldArray) {\r\n                setInputStateValue(isUndefined(defaultValue)\r\n                    ? get(defaultValuesRef.current, name)\r\n                    : defaultValue);\r\n            }\r\n        }\r\n    });\r\n    const props = Object.assign(Object.assign(Object.assign(Object.assign({ name }, rest), (onChange\r\n        ? { [onChangeName]: eventWrapper(onChange) }\r\n        : { [onChangeName]: handleChange })), { [onBlurName]: (...args) => {\r\n            if (onBlur) {\r\n                onBlur(args);\r\n            }\r\n            if (readFormStateRef.current.touched &&\r\n                !get(touchedFieldsRef.current, name)) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                reRender();\r\n            }\r\n            if (shouldReValidateOnBlur) {\r\n                triggerValidation(name);\r\n            }\r\n        } }), { [valueName || (isCheckboxInput ? 'checked' : VALUE)]: value });\r\n    return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(InnerComponent)\r\n        ? Object(react__WEBPACK_IMPORTED_MODULE_0__[\"cloneElement\"])(InnerComponent, props)\r\n        : Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(InnerComponent, props);\r\n};\n\nconst ErrorMessage = (_a) => {\r\n    var { as: InnerComponent, errors, name, message, children } = _a, rest = __rest(_a, [\"as\", \"errors\", \"name\", \"message\", \"children\"]);\r\n    const methods = useFormContext();\r\n    const error = get(errors || methods.errors, name);\r\n    if (!error) {\r\n        return null;\r\n    }\r\n    const { message: messageFromRegister, types } = error;\r\n    const props = Object.assign(Object.assign({}, (InnerComponent ? rest : {})), { children: children\r\n            ? children({ message: messageFromRegister || message, messages: types })\r\n            : messageFromRegister || message });\r\n    return InnerComponent ? (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(InnerComponent) ? (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"cloneElement\"])(InnerComponent, props)) : (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(InnerComponent, props))) : (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(react__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], Object.assign({}, props)));\r\n};\n\n\n\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["E:\\current_project\\PPH\\tfs\\Website\\Website\\node_modules\\react-hook-form\\dist\\react-hook-form.es.js"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmJ;;AAEnJ;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,SAAS,MAAM,oCAAoC;AAClF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc,eAAe;AACtE,CAAC,IAAI;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,YAAY,aAAa,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,wCAAwC,MAAM;AAC9C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,WAAW,QAAQ;;AAEnB;;AAEA,wDAAwD,OAAO;;AAE/D;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO,QAAQ,EAAE;AACxC,oBAAoB;AACpB;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;AACA;;AAEA,mCAAmC,0DAA0D;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,kEAAkE,4DAAc;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,WAAW,sCAAsC,0CAA0C,KAAK,0BAA0B,GAAG;AAC1K;AACA;AACA;;AAEA,iEAAiE,YAAY,oBAAoB,yEAAyE;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAiD;AAChE,eAAe;AACf;AACA;AACA,yCAAyC,6KAA6K;AACtN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uCAAuC;AACtD,eAAe,uCAAuC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,eAAe,oDAAoD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAA+C;AAC9D;AACA,yCAAyC,qEAAqE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,sBAAsB,oCAAoC;AAC/F;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,0BAA0B;AAC1B;AACA,gCAAgC,0BAA0B;AAC1D;AACA,wBAAwB;AACxB;AACA,YAAY,OAAO;AACnB;AACA,uBAAuB,2CAA2C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,4CAA4C,KAAK,GAAG,IAAI,OAAO,KAAK,GAAG,IAAI;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kHAAkH;AACzI;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D,WAAW;AAC1E;;AAEA,qDAAqD,OAAO;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA,kBAAkB,wJAAwJ,kDAAkD,KAAK;AACjO,sBAAsB,oDAAM,GAAG;AAC/B,sBAAsB,oDAAM,GAAG;AAC/B,6BAA6B,oDAAM,GAAG;AACtC,oCAAoC,oDAAM,GAAG;AAC7C,2BAA2B,oDAAM;AACjC,2BAA2B,oDAAM;AACjC,oCAAoC,oDAAM;AAC1C,2BAA2B,oDAAM;AACjC,uBAAuB,oDAAM;AAC7B,6BAA6B,oDAAM;AACnC,qCAAqC,oDAAM,GAAG;AAC9C,sBAAsB,oDAAM;AAC5B,0BAA0B,oDAAM;AAChC,2BAA2B,oDAAM;AACjC,uBAAuB,oDAAM;AAC7B,2BAA2B,oDAAM;AACjC,4BAA4B,oDAAM;AAClC,4BAA4B,oDAAM;AAClC,uCAAuC,oDAAM,GAAG;AAChD,iCAAiC,oDAAM;AACvC,+BAA+B,oDAAM;AACrC,uBAAuB,sDAAQ;AAC/B,WAAW,mCAAmC,GAAG,oDAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,kEAAkE,GAAG,oDAAM;AACtF;AACA,qBAAqB,yDAAW;AAChC;AACA,qBAAqB;AACrB;AACA,KAAK;AACL,oCAAoC,yDAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,yDAAW;AACrC,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,yDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,yDAAW;AACzC;AACA;AACA,iCAAiC,wBAAwB,EAAE,mBAAmB,IAAI,SAAS,IAAI,EAAE;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,6BAA6B,yDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,yDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8CAA8C,yDAAW;AACzD,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,uDAAuD,mBAAmB,KAAK;AAC/E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,uBAAuB;AACvB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAW,aAAa;AAC7D;AACA;AACA;AACA,2HAA2H,mFAAmF,SAAS;AACvN;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,qCAAqC,yDAAW;AAChD;AACA;AACA;AACA,KAAK;AACL,2CAA2C,yDAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4CAA4C;AAC3E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK,qBAAqB;AAC3C;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,cAAc,mFAAmF,MAAM;AAC/L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,yBAAyB;AACzB,6BAA6B,aAAa,EAAE,mDAAmD,kCAAkC,kBAAkB;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,OAAO,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0EAA0E;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAS;AACb;AACA;AACA,YAAY,YAAoB;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;AAC7B;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;AAC7B;AACA;AACA;AACA,oBAAoB,yDAAW;AAC/B,mBAAmB,yDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,+DAA+D;AAC/D,kBAAkB;AAClB,WAAW;AACX,YAAY,KAAK;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA,6BAA6B,yDAAW,yBAAyB,yDAAW,4BAA4B,yDAAW,2CAA2C;AAC9J;;AAEA;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,2DAAa;AACvC;AACA,WAAW,wDAAU;AACrB;AACA;AACA,SAAS,8BAA8B;AACvC,YAAY,2DAAa,8BAA8B,sCAAsC,iBAAiB,oBAAoB,GAAG;AACrI;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,qDAAqD,0BAA0B,8BAA8B,QAAQ;AACrH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,iCAAiC;AACzD;AACA,WAAW,iUAAiU;AAC5U;AACA;AACA;AACA;AACA;AACA,kCAAkC,oDAAM;AACxC,+BAA+B,sDAAQ;AACvC,sCAAsC,sDAAQ;AAC9C,sBAAsB,oDAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,qDAAqD,GAAG,KAAK;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG;AAChG;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6HAA6H,KAAK,GAAG,qDAAqD,IAAI,IAAI;AAClM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D;AACA,2BAA2B,+BAA+B;AAC1D,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK,GAAG,WAAW,IAAI,IAAI;AAC3E;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK,GAAG,eAAe,IAAI,IAAI;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,yDAAW;AACzB,cAAc,yDAAW;AACzB,iBAAiB,yDAAW;AAC5B,gBAAgB,yDAAW;AAC3B,gBAAgB,yDAAW;AAC3B,gBAAgB,yDAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,6KAA6K;AACtL;AACA,WAAW,kHAAkH,mCAAmC,mBAAmB,2CAA2C,cAAc,cAAc,gFAAgF;AAC1U,wCAAwC,sDAAQ;AAChD;AACA;AACA,qBAAqB,oDAAM;AAC3B;AACA;AACA,qBAAqB,oDAAM;AAC3B,uBAAuB,oDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAW;AACrC;AACA;AACA;AACA,wCAAwC,kCAAkC;AAC1E;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAS;AACb;AACA,KAAK;AACL,IAAI,uDAAS;AACb;AACA,KAAK;AACL;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2EAA2E,OAAO;AAClF,WAAW;AACX,WAAW,+BAA+B,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE,IAAI,8DAA8D;AAC7E,WAAW,4DAAc;AACzB,UAAU,0DAAY;AACtB,UAAU,2DAAa;AACvB;;AAEA;AACA,SAAS,sDAAsD;AAC/D;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,gDAAgD,6BAA6B,KAAK;AAClF,wBAAwB,2DAA2D;AACnF,8CAA8C;AAC9C,6BAA6B,4DAAc,oBAAoB,0DAAY,4BAA4B,2DAAa,6BAA6B,2DAAa,CAAC,8CAAQ,kBAAkB;AACzL;;AAEyF","file":"x","sourcesContent":["import { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement, Fragment } from 'react';\n\nvar isNullOrUndefined = (value) => value == null;\n\nvar isArray = (value) => Array.isArray(value);\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nvar isHTMLElement = (value) => isObject(value) && value.nodeType === Node.ELEMENT_NODE;\n\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n};\r\nconst VALUE = 'value';\r\nconst UNDEFINED = 'undefined';\r\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst SELECT = 'select';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\r\nconst REGEX_IS_DEEP_PROP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\nconst REGEX_IS_PLAIN_PROP = /^\\w*$/;\r\nconst REGEX_PROP_NAME = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\nconst REGEX_ESCAPE_CHAR = /\\\\(\\\\)?/g;\r\nconst REGEX_ARRAY_FIELD_INDEX = /[\\d+]/g;\n\nfunction attachEventListeners({ field: { ref }, handleChange, isRadioOrCheckbox, }) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isKey = (value) => !isArray(value) &&\r\n    (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));\n\nvar stringToPath = (string) => {\r\n    const result = [];\r\n    string.replace(REGEX_PROP_NAME, (match, number, quote, string) => {\r\n        result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);\r\n    });\r\n    return result;\r\n};\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!isKey(key)) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = path\r\n        .split(/[,[\\].]+?/)\r\n        .filter(Boolean)\r\n        .reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nfunction castPath(value) {\r\n    return isArray(value) ? value : stringToPath(value);\r\n}\r\nfunction baseGet(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const length = path.length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return index == length ? object : undefined;\r\n}\r\nfunction baseSlice(array, start, end) {\r\n    let index = -1;\r\n    let length = array.length;\r\n    if (start < 0) {\r\n        start = -start > length ? 0 : length + start;\r\n    }\r\n    end = end > length ? length : end;\r\n    if (end < 0) {\r\n        end += length;\r\n    }\r\n    length = start > end ? 0 : end - start;\r\n    const result = Array(length);\r\n    while (++index < length) {\r\n        result[index] = array[index + start];\r\n    }\r\n    return result;\r\n}\r\nfunction parent(object, path) {\r\n    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n}\r\nfunction baseUnset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const childObject = parent(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    const result = !(childObject != null) || delete childObject[key];\r\n    let previousObjRef = undefined;\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef = undefined;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index) {\r\n                if ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (isArray(objectRef) &&\r\n                        !objectRef.filter((data) => isObject(data) && !isEmptyObject(data))\r\n                            .length)) {\r\n                    previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n                }\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction unset(object, paths) {\r\n    paths.forEach((path) => {\r\n        baseUnset(object, path);\r\n    });\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\r\n    const { ref, ref: { name, type }, mutationWatcher, } = field;\r\n    const fieldValue = fields[name];\r\n    if (!type) {\r\n        delete fields[name];\r\n        return;\r\n    }\r\n    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldValue) {\r\n        const { options } = fieldValue;\r\n        if (isArray(options) && options.length) {\r\n            options.filter(Boolean).forEach((option, index) => {\r\n                const { ref, mutationWatcher } = option;\r\n                if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\r\n                    removeAllEventListeners(ref, handleChange);\r\n                    if (mutationWatcher) {\r\n                        mutationWatcher.disconnect();\r\n                    }\r\n                    unset(options, [`[${index}]`]);\r\n                }\r\n            });\r\n            if (options && !options.filter(Boolean).length) {\r\n                delete fields[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fields[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldValue, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        if (mutationWatcher) {\r\n            mutationWatcher.disconnect();\r\n        }\r\n        delete fields[name];\r\n    }\r\n}\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nvar isEmptyString = (value) => value === '';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || isEmptyString(value)\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fields, ref) {\r\n    const { name, value } = ref;\r\n    const field = fields[name];\r\n    if (isFileInput(ref)) {\r\n        return ref.files;\r\n    }\r\n    if (isRadioInput(ref)) {\r\n        return field ? getRadioValue(field.options).value : '';\r\n    }\r\n    if (isMultipleSelect(ref)) {\r\n        return getMultipleSelectValue(ref.options);\r\n    }\r\n    if (isCheckBoxInput(ref)) {\r\n        return field ? getCheckboxValue(field.options).value : false;\r\n    }\r\n    return value;\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar getFieldsValues = (fields, search) => {\r\n    const output = {};\r\n    for (const name in fields) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : isArray(search)\r\n                    ? search.find((data) => name.startsWith(data))\r\n                    : search && search.nest)) {\r\n            output[name] = getFieldValue(fields, fields[name].ref);\r\n        }\r\n    }\r\n    return output;\r\n};\n\nvar compareObject = (objectA = {}, objectB = {}) => {\r\n    const objectAKeys = Object.keys(objectA);\r\n    const objectBKeys = Object.keys(objectB);\r\n    return (objectAKeys.length === objectBKeys.length &&\r\n        objectAKeys.every((key) => objectB[key] && objectB[key] === objectA[key]));\r\n};\n\nvar isSameError = (error, { type, types, message }) => isObject(error) &&\r\n    error.type === type &&\r\n    error.message === message &&\r\n    compareObject(error.types, types);\n\nfunction shouldRenderBasedOnError({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isFieldValid = isEmptyObject(error);\r\n    const isFormValid = isEmptyObject(errors);\r\n    const currentFieldError = get(error, name);\r\n    const existFieldError = get(errors, name);\r\n    if ((isFieldValid && validFields.has(name)) ||\r\n        (existFieldError && existFieldError.isManual)) {\r\n        return false;\r\n    }\r\n    if (isFormValid !== isFieldValid ||\r\n        (!isFormValid && !existFieldError) ||\r\n        (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))) {\r\n        return true;\r\n    }\r\n    return currentFieldError && !isSameError(existFieldError, currentFieldError);\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => {\r\n    const isValueMessage = (value) => isObject(value) && !isRegex(value);\r\n    return isValueMessage(validationData)\r\n        ? validationData\r\n        : {\r\n            value: validationData,\r\n            message: '',\r\n        };\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nvar isMessage = (value) => isString(value) || (isObject(value) && isValidElement(value));\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (validateAllFieldCriteria) {\r\n        const error = errors[name];\r\n        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n    }\r\n    return {};\r\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value, name }, options, required, maxLength, minLength, min, max, pattern, validate, }) => {\r\n    var _a;\r\n    const fields = fieldsRef.current;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = isEmptyString(value);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n        if (!validateAllFieldCriteria) {\r\n            return error;\r\n        }\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value: requiredValue, message: requiredMessage } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (requiredValue) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message: requiredMessage, ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number' || (!type && !isNaN(value))) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue)) {\r\n                exceedMax = valueNumber > maxValue;\r\n            }\r\n            if (!isNullOrUndefined(minValue)) {\r\n                exceedMin = valueNumber < minValue;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxValue)) {\r\n                exceedMax = valueDate > new Date(maxValue);\r\n            }\r\n            if (isString(minValue)) {\r\n                exceedMin = valueDate < new Date(minValue);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\r\n        const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fields, ref);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner)\r\n    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), (path\r\n        ? previous[path] && validateAllFieldCriteria\r\n            ? {\r\n                [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message),\r\n            }\r\n            : {\r\n                [path]: previous[path] || Object.assign({ message,\r\n                    type }, (validateAllFieldCriteria\r\n                    ? {\r\n                        types: { [type]: message || true },\r\n                    }\r\n                    : {})),\r\n            }\r\n        : {}))), {})\r\n    : {\r\n        [error.path]: { message: error.message, type: error.type },\r\n    };\r\nasync function validateWithSchema(validationSchema, validateAllFieldCriteria, data, validationResolver, context) {\r\n    if (validationResolver) {\r\n        return validationResolver(data, context);\r\n    }\r\n    try {\r\n        return {\r\n            values: await validationSchema.validate(data, {\r\n                abortEarly: false,\r\n                context,\r\n            }),\r\n            errors: {},\r\n        };\r\n    }\r\n    catch (e) {\r\n        return {\r\n            values: {},\r\n            errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria)),\r\n        };\r\n    }\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\r\n    const getInnerPath = (value, key, isObject) => {\r\n        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\r\n        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\r\n    };\r\n    return isArray(values)\r\n        ? values.map((value, key) => getInnerPath(value, key))\r\n        : Object.entries(values).map(([key, value]) => getInnerPath(value, key, true));\r\n};\r\nvar getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value;\r\n    watchFields.add(fieldName);\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else if (!isUndefined(fieldValues[fieldName])) {\r\n        value = fieldValues[fieldName];\r\n        watchFields.add(fieldName);\r\n    }\r\n    else {\r\n        value = get(transformToNestObject(fieldValues), fieldName);\r\n        if (!isUndefined(value)) {\r\n            getPath$1(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnChange, hasError, isBlurEvent, isOnSubmit, isReValidateOnSubmit, isOnBlur, isReValidateOnBlur, isSubmitted, }) => (isOnChange && isBlurEvent) ||\r\n    (isOnSubmit && isReValidateOnSubmit) ||\r\n    (isOnSubmit && !isSubmitted) ||\r\n    (isOnBlur && !isBlurEvent && !hasError) ||\r\n    (isReValidateOnBlur && !isBlurEvent && hasError) ||\r\n    (isReValidateOnSubmit && isSubmitted);\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nvar getFieldValueByName = (fields, name) => {\r\n    const results = transformToNestObject(getFieldsValues(fields));\r\n    return name ? get(results, name, results) : results;\r\n};\n\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\r\n    let isMatch = false;\r\n    if (!isArray(referenceArray) ||\r\n        !isArray(differenceArray) ||\r\n        referenceArray.length !== differenceArray.length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < referenceArray.length; i++) {\r\n        if (isMatch) {\r\n            break;\r\n        }\r\n        const dataA = referenceArray[i];\r\n        const dataB = differenceArray[i];\r\n        if (isUndefined(dataB) ||\r\n            Object.keys(dataA).length !== Object.keys(dataB).length) {\r\n            isMatch = true;\r\n            break;\r\n        }\r\n        for (const key in dataA) {\r\n            if (dataA[key] !== dataB[key]) {\r\n                isMatch = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return isMatch;\r\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(element, onDetachCallback) {\r\n    const observer = new MutationObserver(() => {\r\n        if (isDetached(element)) {\r\n            observer.disconnect();\r\n            onDetachCallback();\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, validationResolver, validationContext, defaultValues = {}, submitFocusError = true, validateCriteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const errorsRef = useRef({});\r\n    const touchedFieldsRef = useRef({});\r\n    const fieldArrayDefaultValues = useRef({});\r\n    const watchFieldsRef = useRef(new Set());\r\n    const dirtyFieldsRef = useRef(new Set());\r\n    const fieldsWithValidationRef = useRef(new Set());\r\n    const validFieldsRef = useRef(new Set());\r\n    const isValidRef = useRef(true);\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const defaultValuesAtRenderRef = useRef({});\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const isSubmittedRef = useRef(false);\r\n    const isDirtyRef = useRef(false);\r\n    const submitCountRef = useRef(0);\r\n    const isSubmittingRef = useRef(false);\r\n    const handleChangeRef = useRef();\r\n    const resetFieldArrayFunctionRef = useRef({});\r\n    const validationContextRef = useRef(validationContext);\r\n    const fieldArrayNamesRef = useRef(new Set());\r\n    const [, render] = useState();\r\n    const { isOnBlur, isOnSubmit, isOnChange } = useRef(modeChecker(mode)).current;\r\n    const validateAllFieldCriteria = validateCriteriaMode === 'all';\r\n    const isWindowUndefined = typeof window === UNDEFINED;\r\n    const shouldValidateSchemaOrResolver = !!(validationSchema || validationResolver);\r\n    const isWeb = typeof document !== UNDEFINED &&\r\n        !isWindowUndefined &&\r\n        !isUndefined(window.HTMLElement);\r\n    const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\n    const readFormStateRef = useRef({\r\n        dirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        isSubmitted: isOnSubmit,\r\n        submitCount: !isProxyEnabled,\r\n        touched: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit, } = useRef(modeChecker(reValidateMode)).current;\r\n    validationContextRef.current = validationContext;\r\n    const reRender = useCallback(() => {\r\n        if (!isUnMount.current) {\r\n            render({});\r\n        }\r\n    }, []);\r\n    const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false) => {\r\n        let shouldReRender = shouldRender ||\r\n            shouldRenderBasedOnError({\r\n                errors: errorsRef.current,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        if (isEmptyObject(error)) {\r\n            if (fieldsWithValidationRef.current.has(name) ||\r\n                shouldValidateSchemaOrResolver) {\r\n                validFieldsRef.current.add(name);\r\n                shouldReRender = shouldReRender || get(errorsRef.current, name);\r\n            }\r\n            errorsRef.current = unset(errorsRef.current, [name]);\r\n        }\r\n        else {\r\n            const previousError = get(errorsRef.current, name);\r\n            validFieldsRef.current.delete(name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    (previousError\r\n                        ? !isSameError(previousError, error[name])\r\n                        : true);\r\n            set(errorsRef.current, name, error[name]);\r\n        }\r\n        if (shouldReRender && !isNullOrUndefined(shouldRender)) {\r\n            reRender();\r\n            return true;\r\n        }\r\n    }, [reRender, shouldValidateSchemaOrResolver]);\r\n    const setFieldValue = useCallback((field, rawValue) => {\r\n        const { ref, options } = field;\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref)) {\r\n            if (isString(value)) {\r\n                ref.value = value;\r\n            }\r\n            else {\r\n                ref.files = value;\r\n            }\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = value.includes(checkboxRef.value)))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, [isWeb]);\r\n    const setDirty = useCallback((name) => {\r\n        if (!fieldsRef.current[name] ||\r\n            (!readFormStateRef.current.dirty && !readFormStateRef.current.dirtyFields)) {\r\n            return false;\r\n        }\r\n        let isFieldDirty = defaultValuesAtRenderRef.current[name] !==\r\n            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const previousDirtyFieldsLength = dirtyFieldsRef.current.size;\r\n        if (isFieldArray) {\r\n            const fieldArrayName = getFieldArrayParentName(name);\r\n            isFieldDirty = getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, fieldArrayName), get(defaultValuesRef.current, fieldArrayName));\r\n        }\r\n        const isDirtyChanged = (isFieldArray ? isDirtyRef.current : dirtyFieldsRef.current.has(name)) !==\r\n            isFieldDirty;\r\n        if (isFieldDirty) {\r\n            dirtyFieldsRef.current.add(name);\r\n        }\r\n        else {\r\n            dirtyFieldsRef.current.delete(name);\r\n        }\r\n        isDirtyRef.current = isFieldArray\r\n            ? isFieldDirty\r\n            : !!dirtyFieldsRef.current.size;\r\n        return readFormStateRef.current.dirty\r\n            ? isDirtyChanged\r\n            : previousDirtyFieldsLength !== dirtyFieldsRef.current.size;\r\n    }, []);\r\n    const setInternalValues = useCallback((name, value, parentFieldName) => {\r\n        const isValueArray = isArray(value);\r\n        for (const key in value) {\r\n            const fieldName = `${parentFieldName || name}${isValueArray ? `[${key}]` : `.${key}`}`;\r\n            const field = fieldsRef.current[fieldName];\r\n            if (isObject(value[key])) {\r\n                setInternalValues(name, value[key], fieldName);\r\n            }\r\n            if (field) {\r\n                setFieldValue(field, value[key]);\r\n                setDirty(fieldName);\r\n            }\r\n        }\r\n    }, [setFieldValue, setDirty]);\r\n    const setInternalValue = useCallback((name, value) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            setFieldValue(field, value);\r\n            const output = setDirty(name);\r\n            if (isBoolean(output)) {\r\n                return output;\r\n            }\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value);\r\n        }\r\n    }, [setDirty, setFieldValue, setInternalValues]);\r\n    const executeValidation = useCallback(async (name, skipReRender) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            const error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            shouldRenderBaseOnError(name, error, skipReRender ? null : false);\r\n            return isEmptyObject(error);\r\n        }\r\n        return false;\r\n    }, [shouldRenderBaseOnError, validateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = useCallback(async (payload) => {\r\n        const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fieldsRef.current), validationResolver, validationContextRef.current);\r\n        const previousFormIsValid = isValidRef.current;\r\n        isValidRef.current = isEmptyObject(errors);\r\n        if (isArray(payload)) {\r\n            payload.forEach((name) => {\r\n                const error = get(errors, name);\r\n                if (error) {\r\n                    set(errorsRef.current, name, error);\r\n                }\r\n                else {\r\n                    unset(errorsRef.current, [name]);\r\n                }\r\n            });\r\n            reRender();\r\n        }\r\n        else {\r\n            const error = get(errors, payload);\r\n            shouldRenderBaseOnError(payload, (error ? { [payload]: error } : {}), previousFormIsValid !== isValidRef.current);\r\n        }\r\n        return isEmptyObject(errorsRef.current);\r\n    }, [\r\n        reRender,\r\n        shouldRenderBaseOnError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const triggerValidation = useCallback(async (payload) => {\r\n        const fields = payload || Object.keys(fieldsRef.current);\r\n        if (shouldValidateSchemaOrResolver) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, true)));\r\n            reRender();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [\r\n        executeSchemaOrResolverValidation,\r\n        executeValidation,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n    ]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    function setValue(names, valueOrShouldValidate, shouldValidate) {\r\n        let shouldRender = false;\r\n        const isArrayValue = isArray(names);\r\n        (isArrayValue\r\n            ? names\r\n            : [names]).forEach((name) => {\r\n            const isStringFieldName = isString(name);\r\n            shouldRender =\r\n                setInternalValue(isStringFieldName ? name : Object.keys(name)[0], isStringFieldName\r\n                    ? valueOrShouldValidate\r\n                    : Object.values(name)[0]) || isArrayValue\r\n                    ? true\r\n                    : isFieldWatched(name);\r\n        });\r\n        if (shouldRender || isArrayValue) {\r\n            reRender();\r\n        }\r\n        if (shouldValidate || (isArrayValue && valueOrShouldValidate)) {\r\n            triggerValidation(isArrayValue ? undefined : names);\r\n        }\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            const name = target ? target.name : '';\r\n            const fields = fieldsRef.current;\r\n            const errors = errorsRef.current;\r\n            const field = fields[name];\r\n            const currentError = get(errors, name);\r\n            let error;\r\n            if (!field) {\r\n                return;\r\n            }\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const shouldSkipValidation = skipValidation({\r\n                hasError: !!currentError,\r\n                isOnChange,\r\n                isBlurEvent,\r\n                isOnSubmit,\r\n                isReValidateOnSubmit,\r\n                isOnBlur,\r\n                isReValidateOnBlur,\r\n                isSubmitted: isSubmittedRef.current,\r\n            });\r\n            const shouldUpdateDirty = setDirty(name);\r\n            let shouldRender = isFieldWatched(name) || shouldUpdateDirty;\r\n            if (isBlurEvent &&\r\n                !get(touchedFieldsRef.current, name) &&\r\n                readFormStateRef.current.touched) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                shouldRender = true;\r\n            }\r\n            if (shouldSkipValidation) {\r\n                return shouldRender && reRender();\r\n            }\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fields), validationResolver, validationContextRef.current);\r\n                const previousFormIsValid = isValidRef.current;\r\n                isValidRef.current = isEmptyObject(errors);\r\n                error = (get(errors, name)\r\n                    ? { [name]: get(errors, name) }\r\n                    : {});\r\n                if (previousFormIsValid !== isValidRef.current) {\r\n                    shouldRender = true;\r\n                }\r\n            }\r\n            else {\r\n                error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            }\r\n            if (!shouldRenderBaseOnError(name, error) && shouldRender) {\r\n                reRender();\r\n            }\r\n        };\r\n    const validateSchemaOrResolver = useCallback((values = {}) => {\r\n        const fieldValues = isEmptyObject(defaultValuesRef.current)\r\n            ? getFieldsValues(fieldsRef.current)\r\n            : defaultValuesRef.current;\r\n        validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), validationResolver, validationContextRef.current).then(({ errors }) => {\r\n            const previousFormIsValid = isValidRef.current;\r\n            isValidRef.current = isEmptyObject(errors);\r\n            if (previousFormIsValid !== isValidRef.current) {\r\n                reRender();\r\n            }\r\n        });\r\n    }, \r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [reRender, validateAllFieldCriteria, validationResolver]);\r\n    const removeFieldEventListener = useCallback((field, forceDelete) => {\r\n        if (handleChangeRef.current && field) {\r\n            findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (!field ||\r\n            (field &&\r\n                isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) &&\r\n                !forceDelete)) {\r\n            return;\r\n        }\r\n        removeFieldEventListener(field, forceDelete);\r\n        const { name } = field.ref;\r\n        errorsRef.current = unset(errorsRef.current, [name]);\r\n        touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);\r\n        defaultValuesAtRenderRef.current = unset(defaultValuesAtRenderRef.current, [name]);\r\n        [\r\n            dirtyFieldsRef,\r\n            fieldsWithValidationRef,\r\n            validFieldsRef,\r\n            watchFieldsRef,\r\n        ].forEach((data) => data.current.delete(name));\r\n        if (readFormStateRef.current.isValid ||\r\n            readFormStateRef.current.touched) {\r\n            reRender();\r\n            if (shouldValidateSchemaOrResolver) {\r\n                validateSchemaOrResolver();\r\n            }\r\n        }\r\n    }, [\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        validateSchemaOrResolver,\r\n        removeFieldEventListener,\r\n    ]);\r\n    function clearError(name) {\r\n        if (name) {\r\n            unset(errorsRef.current, isArray(name) ? name : [name]);\r\n        }\r\n        else {\r\n            errorsRef.current = {};\r\n        }\r\n        reRender();\r\n    }\r\n    const setInternalError = ({ name, type, types, message, shouldRender, }) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!isSameError(get(errorsRef.current, name), {\r\n            type,\r\n            message,\r\n            types,\r\n        })) {\r\n            set(errorsRef.current, name, {\r\n                type,\r\n                types,\r\n                message,\r\n                ref: field ? field.ref : {},\r\n                isManual: true,\r\n            });\r\n            if (shouldRender) {\r\n                reRender();\r\n            }\r\n        }\r\n    };\r\n    function setError(name, type = '', message) {\r\n        if (isString(name)) {\r\n            setInternalError(Object.assign(Object.assign({ name }, (isObject(type)\r\n                ? {\r\n                    types: type,\r\n                    type: '',\r\n                }\r\n                : {\r\n                    type,\r\n                    message,\r\n                })), { shouldRender: true }));\r\n        }\r\n        else if (isArray(name)) {\r\n            name.forEach((error) => setInternalError(Object.assign({}, error)));\r\n            reRender();\r\n        }\r\n    }\r\n    function watch(fieldNames, defaultValue) {\r\n        const watchFields = watchFieldsRef.current;\r\n        const isDefaultValueUndefined = isUndefined(defaultValue);\r\n        const combinedDefaultValues = isDefaultValueUndefined\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isDefaultValueUndefined\r\n                ? get(combinedDefaultValues, fieldNames)\r\n                : defaultValue, true);\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = true;\r\n        const result = (!isEmptyObject(fieldValues) && fieldValues) || combinedDefaultValues;\r\n        return fieldNames && fieldNames.nest\r\n            ? transformToNestObject(result)\r\n            : result;\r\n    }\r\n    function unregister(name) {\r\n        if (fieldsRef.current) {\r\n            (isArray(name) ? name : [name]).forEach((fieldName) => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\r\n        }\r\n    }\r\n    function registerFieldsRef(ref, validateOptions = {}) {\r\n        if (!ref.name) {\r\n            // eslint-disable-next-line no-console\r\n            return console.warn('Missing name @', ref);\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let isFieldArray;\r\n        let defaultValue;\r\n        if (isRadioOrCheckbox\r\n            ? field &&\r\n                isArray(field.options) &&\r\n                field.options.filter(Boolean).find((option) => {\r\n                    return value === option.ref.value && option.ref === ref;\r\n                })\r\n            : field && ref === field.ref) {\r\n            fields[name] = Object.assign(Object.assign({}, field), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                            mutationWatcher,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), { mutationWatcher });\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        if (!isEmptyObject(defaultValuesRef.current)) {\r\n            defaultValue = get(defaultValuesRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(field, defaultValue);\r\n            }\r\n        }\r\n        if (shouldValidateSchemaOrResolver &&\r\n            !isFieldArray &&\r\n            readFormStateRef.current.isValid) {\r\n            validateSchemaOrResolver();\r\n        }\r\n        else if (!isEmptyObject(validateOptions)) {\r\n            fieldsWithValidationRef.current.add(name);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, validateAllFieldCriteria, field).then((error) => {\r\n                    const previousFormIsValid = isValidRef.current;\r\n                    isEmptyObject(error)\r\n                        ? validFieldsRef.current.add(name)\r\n                        : (isValidRef.current = false);\r\n                    if (previousFormIsValid !== isValidRef.current) {\r\n                        reRender();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultValuesAtRenderRef.current[name] &&\r\n            !(isFieldArray && isEmptyDefaultValue)) {\r\n            defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, field.ref) : defaultValue;\r\n        }\r\n        if (type) {\r\n            attachEventListeners({\r\n                field: isRadioOrCheckbox && field.options\r\n                    ? field.options[field.options.length - 1]\r\n                    : field,\r\n                isRadioOrCheckbox: isRadioOrCheckbox || isSelectInput(ref),\r\n                handleChange: handleChangeRef.current,\r\n            });\r\n        }\r\n    }\r\n    function register(refOrValidationOptions, validationOptions) {\r\n        if (isWindowUndefined) {\r\n            return;\r\n        }\r\n        if (isString(refOrValidationOptions)) {\r\n            registerFieldsRef({ name: refOrValidationOptions }, validationOptions);\r\n            return;\r\n        }\r\n        if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\r\n            registerFieldsRef(refOrValidationOptions, validationOptions);\r\n            return;\r\n        }\r\n        return (ref) => ref && registerFieldsRef(ref, refOrValidationOptions);\r\n    }\r\n    const handleSubmit = useCallback((callback) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        const fields = fieldsRef.current;\r\n        let fieldValues = getFieldsValues(fields);\r\n        if (readFormStateRef.current.isSubmitting) {\r\n            isSubmittingRef.current = true;\r\n            reRender();\r\n        }\r\n        try {\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors, values } = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(fieldValues), validationResolver, validationContextRef.current);\r\n                errorsRef.current = errors;\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fields)) {\r\n                    if (field) {\r\n                        const { ref: { name }, } = field;\r\n                        const fieldError = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            validFieldsRef.current.delete(name);\r\n                        }\r\n                        else {\r\n                            if (fieldsWithValidationRef.current.has(name)) {\r\n                                validFieldsRef.current.add(name);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors)) {\r\n                errorsRef.current = {};\r\n                reRender();\r\n                await callback(transformToNestObject(fieldValues), e);\r\n            }\r\n            else {\r\n                errorsRef.current = fieldErrors;\r\n                if (submitFocusError && isWeb) {\r\n                    focusOnErrorField(fields, fieldErrors);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            isSubmittedRef.current = true;\r\n            isSubmittingRef.current = false;\r\n            submitCountRef.current = submitCountRef.current + 1;\r\n            reRender();\r\n        }\r\n    }, [\r\n        isWeb,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        submitFocusError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const resetRefs = ({ errors, dirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        fieldsRef.current = {};\r\n        if (!errors) {\r\n            errorsRef.current = {};\r\n        }\r\n        if (!touched) {\r\n            touchedFieldsRef.current = {};\r\n        }\r\n        if (!isValid) {\r\n            validFieldsRef.current = new Set();\r\n            fieldsWithValidationRef.current = new Set();\r\n            isValidRef.current = true;\r\n        }\r\n        if (!dirty) {\r\n            isDirtyRef.current = false;\r\n        }\r\n        if (!dirtyFields) {\r\n            dirtyFieldsRef.current = new Set();\r\n        }\r\n        if (!isSubmitted) {\r\n            isSubmittedRef.current = false;\r\n        }\r\n        if (!submitCount) {\r\n            submitCountRef.current = 0;\r\n        }\r\n        defaultValuesAtRenderRef.current = {};\r\n        fieldArrayDefaultValues.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (values) {\r\n            defaultValuesRef.current = values;\r\n        }\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        resetRefs(omitResetState);\r\n        reRender();\r\n    };\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return fieldsRef.current[payload]\r\n                ? getFieldValue(fieldsRef.current, fieldsRef.current[payload].ref)\r\n                : get(defaultValuesRef.current, payload);\r\n        }\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const outputValues = isEmptyObject(fieldValues)\r\n            ? defaultValuesRef.current\r\n            : fieldValues;\r\n        return payload && payload.nest\r\n            ? transformToNestObject(outputValues)\r\n            : outputValues;\r\n    }\r\n    useEffect(() => () => {\r\n        isUnMount.current = true;\r\n        fieldsRef.current &&\r\n            process.env.NODE_ENV === 'production' &&\r\n            Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, [removeFieldEventListenerAndRef]);\r\n    if (!shouldValidateSchemaOrResolver) {\r\n        isValidRef.current =\r\n            validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&\r\n                isEmptyObject(errorsRef.current);\r\n    }\r\n    const formState = {\r\n        dirty: isDirtyRef.current,\r\n        dirtyFields: dirtyFieldsRef.current,\r\n        isSubmitted: isSubmittedRef.current,\r\n        submitCount: submitCountRef.current,\r\n        touched: touchedFieldsRef.current,\r\n        isSubmitting: isSubmittingRef.current,\r\n        isValid: isOnSubmit\r\n            ? isSubmittedRef.current && isEmptyObject(errorsRef.current)\r\n            : isValidRef.current,\r\n    };\r\n    const commonProps = {\r\n        triggerValidation,\r\n        setValue: useCallback(setValue, [\r\n            reRender,\r\n            setInternalValue,\r\n            triggerValidation,\r\n        ]),\r\n        register: useCallback(register, [\r\n            defaultValuesRef.current,\r\n            defaultValuesAtRenderRef.current,\r\n        ]),\r\n        unregister: useCallback(unregister, []),\r\n        getValues: useCallback(getValues, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = Object.assign(Object.assign(Object.assign({ removeFieldEventListener,\r\n        reRender }, (shouldValidateSchemaOrResolver\r\n        ? { validateSchemaIsValid: validateSchemaOrResolver }\r\n        : {})), { mode: {\r\n            isOnBlur,\r\n            isOnSubmit,\r\n            isOnChange,\r\n        }, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnSubmit,\r\n        }, errorsRef,\r\n        touchedFieldsRef,\r\n        fieldsRef,\r\n        isWatchAllRef,\r\n        watchFieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        fieldArrayDefaultValues,\r\n        validFieldsRef,\r\n        dirtyFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        isDirtyRef,\r\n        readFormStateRef,\r\n        defaultValuesRef }), commonProps);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: useCallback(reset, []), clearError: useCallback(clearError, []), setError: useCallback(setError, []), errors: errorsRef.current }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormGlobalContext = createContext(null);\r\nfunction useFormContext() {\r\n    return useContext(FormGlobalContext);\r\n}\r\nfunction FormContext(_a) {\r\n    var { children, formState, errors } = _a, restMethods = __rest(_a, [\"children\", \"formState\", \"errors\"]);\r\n    return (createElement(FormGlobalContext.Provider, { value: Object.assign(Object.assign({}, restMethods), { formState, errors }) }, children));\r\n}\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nconst appendId = (value, keyName) => (Object.assign({ [keyName]: generateId() }, (isObject(value) ? value : { value })));\r\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\n\nvar getSortRemovedItems = (indexes, removeIndexes, updatedIndexes = [], count = 0, notFoundIndexes = []) => {\r\n    for (const removeIndex of removeIndexes) {\r\n        if (indexes.indexOf(removeIndex) < 0) {\r\n            notFoundIndexes.push(removeIndex);\r\n        }\r\n    }\r\n    for (const index of indexes.sort()) {\r\n        if (removeIndexes.indexOf(index) > -1) {\r\n            updatedIndexes.push(-1);\r\n            count++;\r\n        }\r\n        else {\r\n            updatedIndexes.push(index -\r\n                count -\r\n                (notFoundIndexes.length\r\n                    ? notFoundIndexes\r\n                        .map((notFoundIndex) => notFoundIndex < index)\r\n                        .filter(Boolean).length\r\n                    : 0));\r\n        }\r\n    }\r\n    return updatedIndexes;\r\n};\n\nconst removeAt = (data, index) => [\r\n    ...data.slice(0, index),\r\n    ...data.slice(index + 1),\r\n];\r\nfunction removeAtIndexes(data, index) {\r\n    let k = -1;\r\n    while (++k < data.length) {\r\n        if (index.indexOf(k) >= 0) {\r\n            delete data[k];\r\n        }\r\n    }\r\n    return data.filter(Boolean);\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : isArray(index)\r\n        ? removeAtIndexes(data, index)\r\n        : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(isArray(value) ? value : [value || null]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(isArray(value) ? value : [value || null]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => isArray(value) ? Array(value.length).fill(null) : null;\n\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    const { isWatchAllRef, resetFieldArrayFunctionRef, fieldArrayNamesRef, reRender, fieldsRef, getValues, defaultValuesRef, removeFieldEventListener, errorsRef, dirtyFieldsRef, isDirtyRef, touchedFieldsRef, readFormStateRef, watchFieldsRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValues, validateSchemaIsValid, } = control || methods.control;\r\n    const getDefaultValues = () => [\r\n        ...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)]\r\n            ? fieldArrayDefaultValues.current\r\n            : defaultValuesRef.current, name, []),\r\n    ];\r\n    const memoizedDefaultValues = useRef(getDefaultValues());\r\n    const [fields, setField] = useState(mapIds(memoizedDefaultValues.current, keyName));\r\n    const [isDeleted, setIsDeleted] = useState(false);\r\n    const allFields = useRef(fields);\r\n    const isNameKey = isKey(name);\r\n    allFields.current = fields;\r\n    if (isNameKey) {\r\n        fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\r\n    }\r\n    const appendValueWithKey = (values) => values.map((value) => appendId(value, keyName));\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setField(fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateSchemaIsValid) {\r\n            validateSchemaIsValid({\r\n                [name]: fieldsValues,\r\n            });\r\n        }\r\n    };\r\n    const modifyDirtyFields = ({ shouldRender, isRemove, isPrePend, index, value = {}, } = {}) => {\r\n        let render = shouldRender;\r\n        const values = isArray(value) ? value : [value];\r\n        if (readFormStateRef.current.dirty) {\r\n            const dirtyFieldIndexesAndValues = {};\r\n            if (isPrePend || isRemove) {\r\n                for (const dirtyField of [...dirtyFieldsRef.current].sort()) {\r\n                    if (isMatchFieldArrayName(dirtyField, name)) {\r\n                        const matchedIndexes = dirtyField.match(REGEX_ARRAY_FIELD_INDEX);\r\n                        if (matchedIndexes) {\r\n                            const matchIndex = +matchedIndexes[matchedIndexes.length - 1];\r\n                            if (dirtyFieldIndexesAndValues[matchIndex]) {\r\n                                dirtyFieldIndexesAndValues[matchIndex].push(dirtyField);\r\n                            }\r\n                            else {\r\n                                dirtyFieldIndexesAndValues[matchIndex] = [dirtyField];\r\n                            }\r\n                        }\r\n                        dirtyFieldsRef.current.delete(dirtyField);\r\n                    }\r\n                }\r\n            }\r\n            if (!isUndefined(index) || isPrePend) {\r\n                const updatedDirtyFieldIndexes = isUndefined(index)\r\n                    ? []\r\n                    : getSortRemovedItems(Object.keys(dirtyFieldIndexesAndValues).map((i) => +i), isArray(index) ? index : [index]);\r\n                Object.values(dirtyFieldIndexesAndValues).forEach((values, index) => {\r\n                    const updateIndex = isPrePend ? 0 : updatedDirtyFieldIndexes[index];\r\n                    if (updateIndex > -1) {\r\n                        for (const value of values) {\r\n                            const matchedIndexes = value.match(REGEX_ARRAY_FIELD_INDEX);\r\n                            if (matchedIndexes) {\r\n                                dirtyFieldsRef.current.add(value.replace(/[\\d+]([^[\\d+]+)$/, `${isPrePend\r\n                                    ? +matchedIndexes[matchedIndexes.length - 1] +\r\n                                        values.length\r\n                                    : updateIndex}$1`));\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            if (!isRemove) {\r\n                values.forEach((fieldValue, index) => Object.keys(fieldValue).forEach((key) => dirtyFieldsRef.current.add(`${name}[${isPrePend ? index : allFields.current.length + index}].${key}`)));\r\n                isDirtyRef.current = true;\r\n            }\r\n            render = true;\r\n        }\r\n        if (render && !isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n    };\r\n    const resetFields = (flagOrFields) => {\r\n        if (readFormStateRef.current.dirty) {\r\n            isDirtyRef.current = isUndefined(flagOrFields)\r\n                ? true\r\n                : getIsFieldsDifferent(flagOrFields, defaultValuesRef.current[name] || []);\r\n        }\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n            }\r\n        }\r\n    };\r\n    const mapCurrentFieldsValueWithState = () => {\r\n        const currentFieldsValue = get(getValues({ nest: true }), name);\r\n        if (isArray(currentFieldsValue)) {\r\n            for (let i = 0; i < currentFieldsValue.length; i++) {\r\n                allFields.current[i] = Object.assign(Object.assign({}, allFields.current[i]), currentFieldsValue[i]);\r\n            }\r\n        }\r\n    };\r\n    const append = (value) => {\r\n        setFieldAndValidState([\r\n            ...allFields.current,\r\n            ...(isArray(value)\r\n                ? appendValueWithKey(value)\r\n                : [appendId(value, keyName)]),\r\n        ]);\r\n        modifyDirtyFields({ value });\r\n    };\r\n    const prepend$1 = (value) => {\r\n        let shouldRender = false;\r\n        resetFields();\r\n        setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = prepend(errorsRef.current[name], fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], fillEmptyArray(value));\r\n            shouldRender = true;\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isPrePend: true,\r\n            value,\r\n        });\r\n    };\r\n    const remove = (index) => {\r\n        let shouldRender = false;\r\n        const isIndexUndefined = isUndefined(index);\r\n        if (!isIndexUndefined) {\r\n            mapCurrentFieldsValueWithState();\r\n        }\r\n        resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(removeArrayAt(allFields.current, index));\r\n        setIsDeleted(true);\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = removeArrayAt(errorsRef.current[name], index);\r\n            if (!errorsRef.current[name].filter(Boolean).length) {\r\n                delete errorsRef.current[name];\r\n            }\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);\r\n            shouldRender = true;\r\n        }\r\n        if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\r\n            let fieldIndex = -1;\r\n            let isFound = false;\r\n            const isIndexUndefined = isUndefined(index);\r\n            while (fieldIndex++ < fields.length) {\r\n                const isLast = fieldIndex === fields.length - 1;\r\n                const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\r\n                if (isCurrentIndex || isIndexUndefined) {\r\n                    isFound = true;\r\n                }\r\n                if (!isFound) {\r\n                    continue;\r\n                }\r\n                for (const key in fields[fieldIndex]) {\r\n                    const currentFieldName = `${name}[${fieldIndex}].${key}`;\r\n                    if (isCurrentIndex || isLast || isIndexUndefined) {\r\n                        validFieldsRef.current.delete(currentFieldName);\r\n                        fieldsWithValidationRef.current.delete(currentFieldName);\r\n                    }\r\n                    else {\r\n                        const previousFieldName = `${name}[${fieldIndex - 1}].${key}`;\r\n                        if (validFieldsRef.current.has(currentFieldName)) {\r\n                            validFieldsRef.current.add(previousFieldName);\r\n                        }\r\n                        if (fieldsWithValidationRef.current.has(currentFieldName)) {\r\n                            fieldsWithValidationRef.current.add(previousFieldName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isRemove: true,\r\n            index,\r\n        });\r\n    };\r\n    const insert$1 = (index, value) => {\r\n        mapCurrentFieldsValueWithState();\r\n        resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = insert(errorsRef.current[name], index, fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, fillEmptyArray(value));\r\n            reRender();\r\n        }\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields(fieldValues);\r\n        swapArrayAt(allFields.current, indexA, indexB);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            swapArrayAt(errorsRef.current[name], indexA, indexB);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\r\n            reRender();\r\n        }\r\n    };\r\n    const move = (from, to) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields(fieldValues);\r\n        moveArrayAt(allFields.current, from, to);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            moveArrayAt(errorsRef.current[name], from, to);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            moveArrayAt(touchedFieldsRef.current[name], from, to);\r\n            reRender();\r\n        }\r\n    };\r\n    const reset = () => {\r\n        resetFields();\r\n        memoizedDefaultValues.current = getDefaultValues();\r\n        setField(mapIds(memoizedDefaultValues.current, keyName));\r\n    };\r\n    useEffect(() => {\r\n        if (isNameKey &&\r\n            isDeleted &&\r\n            fieldArrayDefaultValues.current[name] &&\r\n            fields.length < fieldArrayDefaultValues.current[name].length) {\r\n            fieldArrayDefaultValues.current[name].pop();\r\n        }\r\n    }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey]);\r\n    useEffect(() => {\r\n        if (isWatchAllRef && isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n        else if (watchFieldsRef) {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    reRender();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }, [fields, name, reRender, watchFieldsRef, isWatchAllRef]);\r\n    useEffect(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        fieldArrayNames.add(name);\r\n        resetFunctions[name] = reset;\r\n        return () => {\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            fieldArrayNames.delete(name);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    return {\r\n        swap: useCallback(swap, [name]),\r\n        move: useCallback(move, [name]),\r\n        prepend: useCallback(prepend$1, [name]),\r\n        append: useCallback(append, [name]),\r\n        remove: useCallback(remove, [fields, name]),\r\n        insert: useCallback(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nvar getInputValue = (event, isCheckboxInput) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isCheckboxInput || isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nconst Controller = (_a) => {\r\n    var { name, rules, as: InnerComponent, onBlur, onChange, onChangeName = VALIDATION_MODE.onChange, onBlurName = VALIDATION_MODE.onBlur, valueName, defaultValue, control, onFocus } = _a, rest = __rest(_a, [\"name\", \"rules\", \"as\", \"onBlur\", \"onChange\", \"onChangeName\", \"onBlurName\", \"valueName\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, setValue, register, unregister, errorsRef, removeFieldEventListener, triggerValidation, mode: { isOnSubmit, isOnBlur, isOnChange }, reValidateMode: { isReValidateOnBlur, isReValidateOnSubmit }, formState: { isSubmitted }, touchedFieldsRef, readFormStateRef, reRender, fieldsRef, fieldArrayNamesRef, } = control || methods.control;\r\n    const [value, setInputStateValue] = useState(isUndefined(defaultValue)\r\n        ? get(defaultValuesRef.current, name)\r\n        : defaultValue);\r\n    const valueRef = useRef(value);\r\n    const isCheckboxInput = isBoolean(value);\r\n    const shouldReValidateOnBlur = isOnBlur || isReValidateOnBlur;\r\n    const rulesRef = useRef(rules);\r\n    const onFocusRef = useRef(onFocus);\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    rulesRef.current = rules;\r\n    const shouldValidate = () => !skipValidation({\r\n        hasError: !!get(errorsRef.current, name),\r\n        isOnBlur,\r\n        isOnSubmit,\r\n        isOnChange,\r\n        isReValidateOnBlur,\r\n        isReValidateOnSubmit,\r\n        isSubmitted,\r\n    });\r\n    const commonTask = (event) => {\r\n        const data = getInputValue(event, isCheckboxInput);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    };\r\n    const eventWrapper = (event) => (...arg) => setValue(name, commonTask(event(arg)), shouldValidate());\r\n    const handleChange = (event) => {\r\n        const data = commonTask(event);\r\n        setValue(name, data, shouldValidate());\r\n    };\r\n    const registerField = useCallback(() => {\r\n        if (!isNotFieldArray) {\r\n            removeFieldEventListener(fieldsRef.current[name], true);\r\n        }\r\n        register(Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\r\n            set(data) {\r\n                setInputStateValue(data);\r\n                valueRef.current = data;\r\n            },\r\n            get() {\r\n                return valueRef.current;\r\n            },\r\n        }), rulesRef.current);\r\n    }, [\r\n        isNotFieldArray,\r\n        fieldsRef,\r\n        rulesRef,\r\n        name,\r\n        onFocusRef,\r\n        register,\r\n        removeFieldEventListener,\r\n    ]);\r\n    useEffect(() => () => {\r\n        !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\r\n    }, [unregister, name, fieldArrayNamesRef]);\r\n    useEffect(() => {\r\n        registerField();\r\n    }, [registerField]);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    useEffect(() => {\r\n        if (!fieldsRef.current[name]) {\r\n            registerField();\r\n            if (isNotFieldArray) {\r\n                setInputStateValue(isUndefined(defaultValue)\r\n                    ? get(defaultValuesRef.current, name)\r\n                    : defaultValue);\r\n            }\r\n        }\r\n    });\r\n    const props = Object.assign(Object.assign(Object.assign(Object.assign({ name }, rest), (onChange\r\n        ? { [onChangeName]: eventWrapper(onChange) }\r\n        : { [onChangeName]: handleChange })), { [onBlurName]: (...args) => {\r\n            if (onBlur) {\r\n                onBlur(args);\r\n            }\r\n            if (readFormStateRef.current.touched &&\r\n                !get(touchedFieldsRef.current, name)) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                reRender();\r\n            }\r\n            if (shouldReValidateOnBlur) {\r\n                triggerValidation(name);\r\n            }\r\n        } }), { [valueName || (isCheckboxInput ? 'checked' : VALUE)]: value });\r\n    return isValidElement(InnerComponent)\r\n        ? cloneElement(InnerComponent, props)\r\n        : createElement(InnerComponent, props);\r\n};\n\nconst ErrorMessage = (_a) => {\r\n    var { as: InnerComponent, errors, name, message, children } = _a, rest = __rest(_a, [\"as\", \"errors\", \"name\", \"message\", \"children\"]);\r\n    const methods = useFormContext();\r\n    const error = get(errors || methods.errors, name);\r\n    if (!error) {\r\n        return null;\r\n    }\r\n    const { message: messageFromRegister, types } = error;\r\n    const props = Object.assign(Object.assign({}, (InnerComponent ? rest : {})), { children: children\r\n            ? children({ message: messageFromRegister || message, messages: types })\r\n            : messageFromRegister || message });\r\n    return InnerComponent ? (isValidElement(InnerComponent) ? (cloneElement(InnerComponent, props)) : (createElement(InnerComponent, props))) : (createElement(Fragment, Object.assign({}, props)));\r\n};\n\nexport { Controller, ErrorMessage, FormContext, useFieldArray, useForm, useFormContext };\n"]}}